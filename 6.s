#===================== generateCode unsafe =====================
.data

.text
unsafe.__initGlobals:
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode runtime =====================
.data
.runtime.S0:
  .string "Not supported key type"
.runtime.S1:
  .string "Not supported key type"
.runtime.S2:
  .string ""
.runtime.S3:
  .string "panic: "
.runtime.S4:
  .string "\n\n"
.runtime.S5:
  .string "panic: "
.runtime.S6:
  .string "Unknown type"
.runtime.S7:
  .string "\n\n"
.runtime.S8:
  .string "malloc exceeded heap max"
runtime.heapHead: # T T_UINTPTR
  .quad 0
runtime.heapCurrent: # T T_UINTPTR
  .quad 0
runtime.heapTail: # T T_UINTPTR
  .quad 0
runtime.__argv__: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
runtime.envp: # T T_UINTPTR
  .quad 0
runtime.envlines: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
runtime.Envs: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap

.text
runtime.__initGlobals:
  ret
# emitFuncDecl
runtime.$item.valueAddr: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $24, %rax
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.$item.match: # args 48, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq runtime.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.3.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.3.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.3.false # jump if nil
  jmp .L.cmpdtypes.3.cmp # jump to end
.L.cmpdtypes.3.true:
  pushq $1
  jmp .L.cmpdtypes.3.end # jump to end
.L.cmpdtypes.3.false:
  pushq $0
  jmp .L.cmpdtypes.3.end # jump to end
.L.cmpdtypes.3.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.3.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.2 # jump if match
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq runtime.dtype.2(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.5.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.5.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.5.false # jump if nil
  jmp .L.cmpdtypes.5.cmp # jump to end
.L.cmpdtypes.5.true:
  pushq $1
  jmp .L.cmpdtypes.5.end # jump to end
.L.cmpdtypes.5.false:
  pushq $0
  jmp .L.cmpdtypes.5.end # jump to end
.L.cmpdtypes.5.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.5.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.4 # jump if match
  jmp .L.case.6
.L.case.2:
  leaq -32(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq runtime.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.7.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.7.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.7.false # jump if nil
  jmp .L.cmpdtypes.7.cmp # jump to end
.L.cmpdtypes.7.true:
  pushq $1
  jmp .L.cmpdtypes.7.end # jump to end
.L.cmpdtypes.7.false:
  pushq $0
  jmp .L.cmpdtypes.7.end # jump to end
.L.cmpdtypes.7.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.7.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.8 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_type_assertion.8
  .L.unmatch.8:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_type_assertion.8:
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  jmp .L.typeswitch.1.exit
.L.case.4:
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq runtime.dtype.2(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.9.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.9.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.9.false # jump if nil
  jmp .L.cmpdtypes.9.cmp # jump to end
.L.cmpdtypes.9.true:
  pushq $1
  jmp .L.cmpdtypes.9.end # jump to end
.L.cmpdtypes.9.false:
  pushq $0
  jmp .L.cmpdtypes.9.end # jump to end
.L.cmpdtypes.9.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.9.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.10 # jmp if false
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.10
  .L.unmatch.10:
  popq %rax # drop ifc.data
  pushq $0 # T_POINTER zero value
  .L.end_type_assertion.10:
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  jmp .L.typeswitch.1.exit
.L.case.6:
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .runtime.S0, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq runtime.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.1.exit
.L.typeswitch.1.exit:
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .runtime.S1, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq runtime.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.makeMap: # args 40, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq 24(%rbp), %rax # local variable "valueSize"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "addr"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "addr"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.lenMap: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.deleteFromMap: # args 40, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.11 # jmp if false
  leave
  ret
  .L.endif.11:
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.12 # jmp if false
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.12:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.13:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.13 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.14 # jmp if false
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.14:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.13:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.13
  .L.for.exit.13:
  leave
  ret
# emitFuncDecl
runtime.getAddrForMapSet: # args 48, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.15:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.15 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.16 # jmp if false
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.$item.valueAddr
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.16:
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.15:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.15
  .L.for.exit.15:
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $24, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.17 # jmp if false
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.17
  .L.else.17:
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.17:
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.$item.valueAddr
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.getAddrForMapGet: # args 56, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.18:
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.18 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.19 # jmp if false
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.$item.valueAddr
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.19:
  .L.for.post.18:
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.18
  .L.for.exit.18:
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.deleteMap: # args 40, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.20 # jmp if false
  leave
  ret
  .L.endif.20:
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.21 # jmp if false
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.21:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.22:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.22 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.23 # jmp if false
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.23:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.22:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.22
  .L.for.exit.22:
  leave
  ret
# emitFuncDecl
runtime.heapInit: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq runtime.heapHead(%rip), %rax # global variable "heapHead"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.brk
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq runtime.heapTail(%rip), %rax # global variable "heapTail"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq runtime.heapHead(%rip), %rax # global variable "heapHead"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $620205360 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.brk
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq runtime.heapCurrent(%rip), %rax # global variable "heapCurrent"
  pushq %rax # variable address
  leaq runtime.heapHead(%rip), %rax # global variable "heapHead"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
# emitFuncDecl
runtime.envInit: # args 16, locals -121
  pushq %rbp
  movq %rsp, %rbp
  subq $121, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq runtime.envp(%rip), %rax # global variable "envp"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.24:
  pushq $1 # true
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.24 # jmp if false
  leaq -16(%rbp), %rax # local variable "bpp"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "bpp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.25 # jmp if false
jmp .L.for.exit.24 # break
  .L.endif.25:
  leaq runtime.envlines(%rip), %rax # global variable "envlines"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq runtime.envlines(%rip), %rax # global variable "envlines"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "bpp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.cstring2string
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.post.24:
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $8 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.24
  .L.for.exit.24:
  leaq -89(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq runtime.envlines(%rip), %rax # global variable "envlines"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -97(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.26:
  leaq -97(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -89(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.26 # jmp if false
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  leaq -97(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq runtime.envlines(%rip), %rax # global variable "envlines"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -33(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.27:
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -33(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.27 # jmp if false
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $61 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.28 # jmp if false
jmp .L.range.exit.27 # break
  .L.endif.28:
  .L.range.post.27:
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -41(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.27
  .L.range.exit.27:
  leaq -57(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $0 # number literal
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -73(%rbp), %rax # local variable "value"
  pushq %rax # variable address
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq -121(%rbp), %rax # local variable "envline"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -81(%rbp), %rax # local variable "entry"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -57(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -73(%rbp), %rax # local variable "value"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq runtime.Envs(%rip), %rax # global variable "Envs"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq runtime.Envs(%rip), %rax # global variable "Envs"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -81(%rbp), %rax # local variable "entry"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.append8
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.range.post.26:
  leaq -97(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -97(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.26
  .L.range.exit.26:
  leave
  ret
# emitFuncDecl
runtime.runtime_getenv: # args 48, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq runtime.Envs(%rip), %rax # global variable "Envs"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.29:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.29 # jmp if false
  leaq -32(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq runtime.Envs(%rip), %rax # global variable "Envs"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 16(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.30 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.30:
  .L.range.post.29:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.29
  .L.range.exit.29:
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.cstring2string: # args 40, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.cond.31:
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.33.true
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.33.exit
  .L.33.true:
  pushq $1 # true
  .L.33.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.32 # jmp if false
jmp .L.for.exit.31 # break
  .L.endif.32:
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.31:
  jmp .L.for.cond.31
  .L.for.exit.31:
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.runtime_args: # args 40, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq runtime.__argv__(%rip), %rax # global variable "__argv__"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.34:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.34 # jmp if false
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq runtime.__argv__(%rip), %rax # global variable "__argv__"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.cstring2string
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.range.post.34:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.34
  .L.range.exit.34:
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.brk: # args 32, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $12 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "addr"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.panic: # args 32, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq runtime.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.37.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.37.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.37.false # jump if nil
  jmp .L.cmpdtypes.37.cmp # jump to end
.L.cmpdtypes.37.true:
  pushq $1
  jmp .L.cmpdtypes.37.end # jump to end
.L.cmpdtypes.37.false:
  pushq $0
  jmp .L.cmpdtypes.37.end # jump to end
.L.cmpdtypes.37.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.37.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.36 # jump if match
  jmp .L.case.38
.L.case.36:
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .runtime.S3, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $2 # str len
  leaq .runtime.S4, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.Write
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $60 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  jmp .L.typeswitch.35.exit
.L.case.38:
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .runtime.S5, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $12 # str len
  leaq .runtime.S6, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $2 # str len
  leaq .runtime.S7, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.Write
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $60 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  jmp .L.typeswitch.35.exit
.L.typeswitch.35.exit:
  leave
  ret
# emitFuncDecl
runtime.memzeropad: # args 32, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "addr1"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "isize"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "up"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.39:
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -16(%rbp), %rax # local variable "isize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.39 # jmp if false
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -32(%rbp), %rax # local variable "up"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "up"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.39:
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.39
  .L.for.exit.39:
  leave
  ret
# emitFuncDecl
runtime.memcopy: # args 40, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "srcp"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "dstp"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.40:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "length"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.40 # jmp if false
  leaq -16(%rbp), %rax # local variable "srcp"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "src"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "dstp"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "dst"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "dstp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -16(%rbp), %rax # local variable "srcp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.for.post.40:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.40
  .L.for.exit.40:
  leave
  ret
# emitFuncDecl
runtime.malloc: # args 32, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq runtime.heapCurrent(%rip), %rax # global variable "heapCurrent"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq runtime.heapTail(%rip), %rax # global variable "heapTail"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.41 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $24 # str len
  leaq .runtime.S8, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.Write
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $60 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.41:
  leaq -8(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  leaq runtime.heapCurrent(%rip), %rax # global variable "heapCurrent"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq runtime.heapCurrent(%rip), %rax # global variable "heapCurrent"
  pushq %rax # variable address
  leaq runtime.heapCurrent(%rip), %rax # global variable "heapCurrent"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.memzeropad
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.makeSlice: # args 64, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "scap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "addr"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "size"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "addr"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "slen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq 32(%rbp), %rax # local variable "scap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.append1: # args 65, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.42 # jmp if false
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.42
  .L.else.42:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.43 # jmp if false
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.43
  .L.else.43:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.43:
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.44 # jmp if false
  subq $24, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.44:
  .L.endif.42:
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq 40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq 41(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 49(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 57(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.append8: # args 72, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  pushq $8 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.45 # jmp if false
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.45
  .L.else.45:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.46 # jmp if false
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.46
  .L.else.46:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.46:
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.47 # jmp if false
  subq $24, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.47:
  .L.endif.45:
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq 40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 64(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.append16: # args 80, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  pushq $16 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.48 # jmp if false
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.48
  .L.else.48:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.49 # jmp if false
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.49
  .L.else.49:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.49:
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.50 # jmp if false
  subq $24, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.50:
  .L.endif.48:
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq 40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 56(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 64(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 72(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.append24: # args 88, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  pushq $24 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.51 # jmp if false
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.51
  .L.else.51:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.52 # jmp if false
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.52
  .L.else.52:
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.52:
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "newcap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "elmSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.53 # jmp if false
  subq $24, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "old"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "oldSize"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.53:
  .L.endif.51:
  leaq -40(%rbp), %rax # local variable "oldlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq 40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 64(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 72(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "newlen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 80(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "new_"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.catstrings: # args 64, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -8(%rbp), %rax # local variable "totallen"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "totallen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "totallen"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.54:
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.54 # jmp if false
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.for.post.54:
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.54
  .L.for.exit.54:
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.55:
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.55 # jmp if false
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.for.post.55:
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.55
  .L.for.exit.55:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.cmpstrings: # args 56, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.56 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.56:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.57:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.57 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.58 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.58:
  .L.for.post.57:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.57
  .L.for.exit.57:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
runtime.cmpinterface: # args 56, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.60.false
  leaq 24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 40(%rbp), %rax # local variable "d"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.60.exit
  .L.60.false:
  pushq $0 # false
  .L.60.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.59 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.59:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data
runtime.dtype.1: # runtime:string
  .quad 1
  .quad .runtime.S.dtype.1
  .quad 6
.runtime.S.dtype.1:
  .string "string"
runtime.dtype.2: # runtime:unsafe.Pointer
  .quad 2
  .quad .runtime.S.dtype.2
  .quad 14
.runtime.S.dtype.2:
  .string "unsafe.Pointer"

#===================== generateCode reflect =====================
.data

.text
reflect.__initGlobals:
  ret
# emitFuncDecl
reflect.TypeOf: # args 40, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
reflect.$Type.String: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$rtype.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
reflect.$rtype.String: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode syscall =====================
.data

.text
syscall.__initGlobals:
  ret
# emitFuncDecl
syscall.Read: # args 64, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "_cap"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "_cap"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
syscall.Open: # args 64, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $2 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 32(%rbp), %rax # local variable "mode"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 40(%rbp), %rax # local variable "perm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
syscall.Write: # args 64, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "_len"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  pushq $0 # T_UINTPTR zero value
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "_len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ret"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
syscall.Getdents: # args 64, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "_p0"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "_p0"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $217 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "_p0"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode os =====================
.data
os.Args: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap

.text
os.__initGlobals:
  ret
# emitFuncDecl
os.init: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq os.Args(%rip), %rax # global variable "Args"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq runtime.runtime_args
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leave
  ret
# emitFuncDecl
os.Getenv: # args 48, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.runtime_getenv
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
os.Exit: # args 24, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $60 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "status"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Syscall
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode mylib2 =====================
.data

.text
mylib2.__initGlobals:
  ret
# emitFuncDecl
mylib2.Sum2: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode mymap =====================
.data
.mymap.S0:
  .string "Not supported key type"
.mymap.S1:
  .string "Not supported key type"

.text
mymap.__initGlobals:
  ret
# emitFuncDecl
mymap.$item.Next: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mymap.$item.GetKeyAsString: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq mymap.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.61.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.61.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.61.false # jump if nil
  jmp .L.cmpdtypes.61.cmp # jump to end
.L.cmpdtypes.61.true:
  pushq $1
  jmp .L.cmpdtypes.61.end # jump to end
.L.cmpdtypes.61.false:
  pushq $0
  jmp .L.cmpdtypes.61.end # jump to end
.L.cmpdtypes.61.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.61.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.62 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_type_assertion.62
  .L.unmatch.62:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_type_assertion.62:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
mymap.$item.match: # args 48, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq mymap.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.65.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.65.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.65.false # jump if nil
  jmp .L.cmpdtypes.65.cmp # jump to end
.L.cmpdtypes.65.true:
  pushq $1
  jmp .L.cmpdtypes.65.end # jump to end
.L.cmpdtypes.65.false:
  pushq $0
  jmp .L.cmpdtypes.65.end # jump to end
.L.cmpdtypes.65.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.65.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.64 # jump if match
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq mymap.dtype.2(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.67.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.67.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.67.false # jump if nil
  jmp .L.cmpdtypes.67.cmp # jump to end
.L.cmpdtypes.67.true:
  pushq $1
  jmp .L.cmpdtypes.67.end # jump to end
.L.cmpdtypes.67.false:
  pushq $0
  jmp .L.cmpdtypes.67.end # jump to end
.L.cmpdtypes.67.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.67.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.66 # jump if match
  jmp .L.case.68
.L.case.64:
  leaq -32(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq mymap.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.69.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.69.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.69.false # jump if nil
  jmp .L.cmpdtypes.69.cmp # jump to end
.L.cmpdtypes.69.true:
  pushq $1
  jmp .L.cmpdtypes.69.end # jump to end
.L.cmpdtypes.69.false:
  pushq $0
  jmp .L.cmpdtypes.69.end # jump to end
.L.cmpdtypes.69.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.69.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.70 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_type_assertion.70
  .L.unmatch.70:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_type_assertion.70:
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  jmp .L.typeswitch.63.exit
.L.case.66:
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq mymap.dtype.2(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.71.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.71.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.71.false # jump if nil
  jmp .L.cmpdtypes.71.cmp # jump to end
.L.cmpdtypes.71.true:
  pushq $1
  jmp .L.cmpdtypes.71.end # jump to end
.L.cmpdtypes.71.false:
  pushq $0
  jmp .L.cmpdtypes.71.end # jump to end
.L.cmpdtypes.71.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.71.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.72 # jmp if false
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.72
  .L.unmatch.72:
  popq %rax # drop ifc.data
  pushq $0 # T_POINTER zero value
  .L.end_type_assertion.72:
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  jmp .L.typeswitch.63.exit
.L.case.68:
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .mymap.S0, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq mymap.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.63.exit
.L.typeswitch.63.exit:
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .mymap.S1, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq mymap.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
mymap.$Map.Len: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mymap.$Map.First: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mymap.$Map.Get: # args 64, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.73:
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.73 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.74 # jmp if false
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.74:
  .L.for.post.73:
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.73
  .L.for.exit.73:
  leaq 40(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq 56(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mymap.$Map.Delete: # args 40, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.75 # jmp if false
  leave
  ret
  .L.endif.75:
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.76 # jmp if false
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.76:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.77:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.77 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.78 # jmp if false
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.78:
  leaq -8(%rbp), %rax # local variable "prev"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.77:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.77
  .L.for.exit.77:
  leave
  ret
# emitFuncDecl
mymap.$Map.Set: # args 56, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.79:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.79 # jmp if false
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$item.match
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.80 # jmp if false
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq 40(%rbp), %rax # local variable "value"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leave
  ret
  .L.endif.80:
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.79:
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "item"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.79
  .L.for.exit.79:
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $40
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq 24(%rbp), %rax # local variable "key"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq 40(%rbp), %rax # local variable "value"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.81 # jmp if false
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.81
  .L.else.81:
  leaq -8(%rbp), %rax # local variable "last"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "newItem"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.81:
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret

# ------- Dynamic Types ------
.data
mymap.dtype.1: # mymap:string
  .quad 1
  .quad .mymap.S.dtype.1
  .quad 6
.mymap.S.dtype.1:
  .string "string"
mymap.dtype.2: # mymap:unsafe.Pointer
  .quad 2
  .quad .mymap.S.dtype.2
  .quad 14
.mymap.S.dtype.2:
  .string "unsafe.Pointer"

#===================== generateCode strconv =====================
.data
.strconv.S0:
  .string "0"

.text
strconv.__initGlobals:
  ret
# emitFuncDecl
strconv.Itoa: # args 40, locals -89
  pushq %rbp
  movq %rsp, %rbp
  subq $89, %rsp # local area
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.82 # jmp if false
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # str len
  leaq .strconv.S0, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.82:
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $100 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $100 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $100 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $100 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -56(%rbp), %rax # local variable "next"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "right"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "minus"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "minus"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.83:
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.83 # jmp if false
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.84 # jmp if false
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "minus"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $45 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  jmp .L.endif.84
  .L.else.84:
  leaq -56(%rbp), %rax # local variable "next"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  movq $0, %rdx # init %rdx
  divq %rcx
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "right"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable "next"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "ival"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "next"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $48 # convert char literal to int
  leaq -64(%rbp), %rax # local variable "right"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.endif.84:
  .L.for.post.83:
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.83
  .L.for.exit.83:
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -89(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.85:
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.85 # jmp if false
  leaq -89(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -80(%rbp), %rax # local variable "minus"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.86 # jmp if false
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -89(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  jmp .L.endif.86
  .L.else.86:
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -89(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.endif.86:
  .L.for.post.85:
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.85
  .L.for.exit.85:
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -72(%rbp), %rax # local variable "ix"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -48(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
strconv.Atoi: # args 40, locals -42
  pushq %rbp
  movq %rsp, %rbp
  subq $42, %rsp # local area
  leaq 16(%rbp), %rax # local variable "gs"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.87 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.87:
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "isMinus"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -25(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "gs"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -33(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.88:
  leaq -33(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -25(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.88 # jmp if false
  leaq -42(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -33(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "gs"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -42(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $46 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.89 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $999 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.89:
  leaq -42(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $45 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.90 # jmp if false
  leaq -16(%rbp), %rax # local variable "isMinus"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
jmp .L.range.post.88 # continue
  .L.endif.90:
  leaq -17(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -42(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $48 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -17(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.post.88:
  leaq -33(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -33(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.88
  .L.range.exit.88:
  leaq -16(%rbp), %rax # local variable "isMinus"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.91 # jmp if false
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.91:
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode strings =====================
.data
.strings.S0:
  .string "no supported"

.text
strings.__initGlobals:
  ret
# emitFuncDecl
strings.Split: # args 72, locals -74
  pushq %rbp
  movq %rsp, %rbp
  subq $74, %rsp # local area
  leaq 32(%rbp), %rax # local variable "ssep"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.92 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .strings.S0, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq strings.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.92:
  leaq -1(%rbp), %rax # local variable "sepchar"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq 32(%rbp), %rax # local variable "ssep"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -57(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -65(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.93:
  leaq -65(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -57(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.93 # jmp if false
  leaq -74(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -65(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -74(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq -1(%rbp), %rax # local variable "sepchar"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.94 # jmp if false
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.94
  .L.else.94:
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -74(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.endif.94:
  .L.range.post.93:
  leaq -65(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -65(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.93
  .L.range.exit.93:
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -25(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -49(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.HasPrefix: # args 56, locals -25
  pushq %rbp
  movq %rsp, %rbp
  subq $25, %rsp # local area
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 32(%rbp), %rax # local variable "prefix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.95:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.95 # jmp if false
  leaq -25(%rbp), %rax # local variable "bp"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "prefix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -25(%rbp), %rax # local variable "bp"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.96 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.96:
  .L.range.post.95:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.95
  .L.range.exit.95:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.HasSuffix: # args 56, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq 32(%rbp), %rax # local variable "suffix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.97 # jmp if false
  leaq -8(%rbp), %rax # local variable "low"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq 32(%rbp), %rax # local variable "suffix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "lensb"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "suf"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "sb"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "suf"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "sb"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  leaq -8(%rbp), %rax # local variable "low"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -16(%rbp), %rax # local variable "lensb"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable "low"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  leaq -8(%rbp), %rax # local variable "low"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable "sb"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $48, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "suf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 32(%rbp), %rax # local variable "suffix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq strings.eq2
  addq $48, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.97:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.eq2: # args 72, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  leaq 40(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.98 # jmp if false
  leaq 64(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.98:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.99:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.99 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 40(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.100 # jmp if false
  leaq 64(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.100:
  .L.for.post.99:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.99
  .L.for.exit.99:
  leaq 64(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.Contains: # args 56, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 32(%rbp), %rax # local variable "substr"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.Index
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.Index: # args 56, locals -49
  pushq %rbp
  movq %rsp, %rbp
  subq $49, %rsp # local area
  leaq -8(%rbp), %rax # local variable "in"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "subIndex"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.101:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.101 # jmp if false
  leaq -49(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -8(%rbp), %rax # local variable "in"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.103.false
  leaq -49(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $0 # number literal
  leaq 32(%rbp), %rax # local variable "substr"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.103.exit
  .L.103.false:
  pushq $0 # false
  .L.103.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.102 # jmp if false
  leaq -8(%rbp), %rax # local variable "in"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "subIndex"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.102:
  leaq -8(%rbp), %rax # local variable "in"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.104 # jmp if false
  leaq -49(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq -16(%rbp), %rax # local variable "subIndex"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "substr"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.105 # jmp if false
  leaq -16(%rbp), %rax # local variable "subIndex"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "substr"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.106 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.106:
  jmp .L.endif.105
  .L.else.105:
  leaq -8(%rbp), %rax # local variable "in"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "subIndex"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.105:
  .L.endif.104:
  .L.range.post.101:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.101
  .L.range.exit.101:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
strings.LastIndexByte: # args 41, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.107:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.107 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  leaq 32(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.108 # jmp if false
  leaq 33(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.108:
  .L.for.post.107:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.107
  .L.for.exit.107:
  leaq 33(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data
strings.dtype.1: # strings:string
  .quad 1
  .quad .strings.S.dtype.1
  .quad 6
.strings.S.dtype.1:
  .string "string"

#===================== generateCode token =====================
.data
.token.S0:
  .string "INT"
.token.S1:
  .string "STRING"
.token.S2:
  .string "+"
.token.S3:
  .string "-"
.token.S4:
  .string "&"
token.INT: # T T_STRING
  .quad .token.S0
  .quad 3
token.STRING: # T T_STRING
  .quad .token.S1
  .quad 6
token.NoPos: # T T_INT
  .quad 0
token.ADD: # T T_STRING
  .quad .token.S2
  .quad 1
token.SUB: # T T_STRING
  .quad .token.S3
  .quad 1
token.AND: # T T_STRING
  .quad .token.S4
  .quad 1

.text
token.__initGlobals:
  ret
# emitFuncDecl
token.Token.String: # args 48, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "tok"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode fmt =====================
.data
.fmt.S0:
  .string "%!s(int="
.fmt.S1:
  .string ")"
.fmt.S2:
  .string "unknown type"
.fmt.S3:
  .string "%!d(string="
.fmt.S4:
  .string ")"
.fmt.S5:
  .string "unknown type"
.fmt.S6:
  .string "Sprintf: Unknown format:"

.text
fmt.__initGlobals:
  ret
# emitFuncDecl
fmt.Sprintf: # args 72, locals -277
  pushq %rbp
  movq %rsp, %rbp
  subq $277, %rsp # local area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "inPercent"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "argIndex"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -260(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "format"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -268(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.109:
  leaq -268(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -260(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.109 # jmp if false
  leaq -277(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  leaq -268(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "format"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -32(%rbp), %rax # local variable "inPercent"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.110 # jmp if false
  leaq -277(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $37 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.111 # jmp if false
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $37 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  jmp .L.endif.111
  .L.else.111:
  leaq -56(%rbp), %rax # local variable "arg"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "argIndex"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -57(%rbp), %rax # local variable "sign"
  pushq %rax # variable address
  leaq -277(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -57(%rbp), %rax # local variable "sign"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $115 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.113 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $100 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.114 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $84 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.115 # jump if match
  jmp .L.case.116
  addq $1, %rsp # revert stack top
.L.case.113:
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "arg"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq fmt.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.119.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.119.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.119.false # jump if nil
  jmp .L.cmpdtypes.119.cmp # jump to end
.L.cmpdtypes.119.true:
  pushq $1
  jmp .L.cmpdtypes.119.end # jump to end
.L.cmpdtypes.119.false:
  pushq $0
  jmp .L.cmpdtypes.119.end # jump to end
.L.cmpdtypes.119.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.119.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.118 # jump if match
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq fmt.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.121.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.121.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.121.false # jump if nil
  jmp .L.cmpdtypes.121.cmp # jump to end
.L.cmpdtypes.121.true:
  pushq $1
  jmp .L.cmpdtypes.121.end # jump to end
.L.cmpdtypes.121.false:
  pushq $0
  jmp .L.cmpdtypes.121.end # jump to end
.L.cmpdtypes.121.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.121.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.120 # jump if match
  jmp .L.case.122
.L.case.118:
  leaq -105(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  leaq -105(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.117.exit
.L.case.120:
  leaq -113(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -129(%rbp), %rax # local variable "strNumber"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -113(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -113(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  leaq -89(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .fmt.S0, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -129(%rbp), %rax # local variable "strNumber"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .fmt.S1, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.117.exit
.L.case.122:
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  pushq $12 # str len
  leaq .fmt.S2, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.117.exit
.L.typeswitch.117.exit:
  leaq -137(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -145(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.123:
  leaq -145(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -137(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.123 # jmp if false
  leaq -154(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  leaq -145(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -154(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.range.post.123:
  leaq -145(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -145(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.123
  .L.range.exit.123:
  jmp .L.switch.112.exit
.L.case.114:
  leaq -170(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "arg"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -170(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq fmt.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.126.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.126.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.126.false # jump if nil
  jmp .L.cmpdtypes.126.cmp # jump to end
.L.cmpdtypes.126.true:
  pushq $1
  jmp .L.cmpdtypes.126.end # jump to end
.L.cmpdtypes.126.false:
  pushq $0
  jmp .L.cmpdtypes.126.end # jump to end
.L.cmpdtypes.126.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.126.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.125 # jump if match
  leaq -170(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq fmt.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.128.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.128.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.128.false # jump if nil
  jmp .L.cmpdtypes.128.cmp # jump to end
.L.cmpdtypes.128.true:
  pushq $1
  jmp .L.cmpdtypes.128.end # jump to end
.L.cmpdtypes.128.false:
  pushq $0
  jmp .L.cmpdtypes.128.end # jump to end
.L.cmpdtypes.128.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.128.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.127 # jump if match
  jmp .L.case.129
.L.case.125:
  leaq -186(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  leaq -170(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .fmt.S3, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -186(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .fmt.S4, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.124.exit
.L.case.127:
  leaq -194(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  leaq -170(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -194(%rbp), %rax # local variable "_arg"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.124.exit
.L.case.129:
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  pushq $12 # str len
  leaq .fmt.S5, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.124.exit
.L.typeswitch.124.exit:
  leaq -202(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -210(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.130:
  leaq -210(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -202(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.130 # jmp if false
  leaq -219(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  leaq -210(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -219(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.range.post.130:
  leaq -210(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -210(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.130
  .L.range.exit.130:
  jmp .L.switch.112.exit
.L.case.115:
  leaq -227(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "arg"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -227(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.131 # jmp if false
  jmp .L.endif.131
  .L.else.131:
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -227(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  .L.endif.131:
  leaq -235(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -243(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.132:
  leaq -243(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -235(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.132 # jmp if false
  leaq -252(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  leaq -243(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -73(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -252(%rbp), %rax # local variable "_c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.range.post.132:
  leaq -243(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -243(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.132
  .L.range.exit.132:
  jmp .L.switch.112.exit
.L.case.116:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $24 # str len
  leaq .fmt.S6, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -57(%rbp), %rax # local variable "sign"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq fmt.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.112.exit
.L.switch.112.exit:
  leaq -40(%rbp), %rax # local variable "argIndex"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "argIndex"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.endif.111:
  leaq -32(%rbp), %rax # local variable "inPercent"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.110
  .L.else.110:
  leaq -277(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $37 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.133 # jmp if false
  leaq -32(%rbp), %rax # local variable "inPercent"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.endif.133
  .L.else.133:
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -277(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.endif.133:
  .L.endif.110:
  .L.range.post.109:
  leaq -268(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -268(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.109
  .L.range.exit.109:
  leaq 56(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
fmt.Printf: # args 56, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "format"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq syscall.Write
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  leave
  ret

# ------- Dynamic Types ------
.data
fmt.dtype.1: # fmt:string
  .quad 1
  .quad .fmt.S.dtype.1
  .quad 6
.fmt.S.dtype.1:
  .string "string"
fmt.dtype.2: # fmt:int
  .quad 2
  .quad .fmt.S.dtype.2
  .quad 3
.fmt.S.dtype.2:
  .string "int"

#===================== generateCode mylib =====================
.data
.mylib.S0:
  .string "getdents failed"
mylib._buf: # T T_ARRAY
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value

.text
mylib.__initGlobals:
  ret
# emitFuncDecl
mylib.$Type.Method: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "mt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.InArray: # args 64, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 32(%rbp), %rax # local variable "list"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.134:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.134 # jmp if false
  leaq -40(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "list"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.135 # jmp if false
  leaq 56(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.135:
  .L.range.post.134:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.134
  .L.range.exit.134:
  leaq 56(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.Sum: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.Sum2: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mylib2.Sum2
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.Cstring2string: # args 40, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -24(%rbp), %rax # local variable "bs"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.cond.136:
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.138.true
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.138.exit
  .L.138.true:
  pushq $1 # true
  .L.138.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.137 # jmp if false
jmp .L.for.exit.136 # break
  .L.endif.137:
  leaq -24(%rbp), %rax # local variable "bs"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "bs"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.136:
  jmp .L.for.cond.136
  .L.for.exit.136:
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "bs"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.print_dirp: # args 24, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leave
  ret
# emitFuncDecl
mylib.GetDirents: # args 56, locals -136
  pushq %rbp
  movq %rsp, %rbp
  subq $136, %rsp # local area
  leaq -24(%rbp), %rax # local variable "entries"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "dir"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Open
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
# len lhs=2
# returnTypes=2
  leaq -32(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_INT
  leaq -56(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  pushq $1024 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $1024 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq mylib._buf(%rip), %rax # global variable "_buf"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.139:
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq syscall.Getdents
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
# len lhs=2
# returnTypes=2
  leaq -72(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_INT
  leaq -72(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.140 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .mylib.S0, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq mylib.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.140:
  leaq -72(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.141 # jmp if false
jmp .L.for.exit.139 # break
  .L.endif.141:
  leaq -88(%rbp), %rax # local variable "bpos"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.142:
  leaq -88(%rbp), %rax # local variable "bpos"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable "nread"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.142 # jmp if false
  leaq -96(%rbp), %rax # local variable "dirp"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -104(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # number literal
  leaq -56(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -88(%rbp), %rax # local variable "bpos"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -96(%rbp), %rax # local variable "dirp"
  pushq %rax # variable address
  leaq -104(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -112(%rbp), %rax # local variable "pp"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable "dirp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $19, %rax
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -120(%rbp), %rax # local variable "bp"
  pushq %rax # variable address
  leaq -112(%rbp), %rax # local variable "pp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -136(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -120(%rbp), %rax # local variable "bp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mylib.Cstring2string
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -24(%rbp), %rax # local variable "entries"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "entries"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -136(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -88(%rbp), %rax # local variable "bpos"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable "bpos"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -96(%rbp), %rax # local variable "dirp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_UINT16
  movzwq 0(%rax), %rax # load uint16
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.142:
  jmp .L.for.cond.142
  .L.for.exit.142:
  .L.for.post.139:
  jmp .L.for.cond.139
  .L.for.exit.139:
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "entries"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.needSwap: # args 56, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.143 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.143:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.144:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.144 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.145 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.145:
  leaq -16(%rbp), %rax # local variable "aa"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "bb"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "aa"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "bb"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.146 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  jmp .L.endif.146
  .L.else.146:
  leaq -16(%rbp), %rax # local variable "aa"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "bb"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.147 # jmp if false
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.147:
  .L.endif.146:
  .L.for.post.144:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.144
  .L.for.exit.144:
  leaq 48(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
mylib.SortStrings: # args 40, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.148:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.148 # jmp if false
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.149:
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.149 # jmp if false
  leaq -32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq mylib.needSwap
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.150 # jmp if false
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -48(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.endif.150
  .L.else.150:
  .L.endif.150:
  .L.for.post.149:
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.149
  .L.for.exit.149:
  .L.for.post.148:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.148
  .L.for.exit.148:
  leave
  ret

# ------- Dynamic Types ------
.data
mylib.dtype.1: # mylib:string
  .quad 1
  .quad .mylib.S.dtype.1
  .quad 6
.mylib.S.dtype.1:
  .string "string"

#===================== generateCode path =====================
.data
.path.S0:
  .string "."
.path.S1:
  .string "/"
.path.S2:
  .string "/"
.path.S3:
  .string "."
.path.S4:
  .string "/"
.path.S5:
  .string "/"

.text
path.__initGlobals:
  ret
# emitFuncDecl
path.Dir: # args 48, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.151 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # str len
  leaq .path.S0, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.151:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .path.S1, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.152 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # str len
  leaq .path.S2, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.152:
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $17, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $47 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq strings.LastIndexByte
  addq $17, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.153 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.153:
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
path.Base: # args 48, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.154 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # str len
  leaq .path.S3, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.154:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .path.S4, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.155 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # str len
  leaq .path.S5, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.155:
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $47 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.156 # jmp if false
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $0 # number literal
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  .L.endif.156:
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $17, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $47 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq strings.LastIndexByte
  addq $17, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.157 # jmp if false
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  .L.endif.157:
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  leaq -8(%rbp), %rax # local variable "found"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  leaq 16(%rbp), %rax # local variable "path"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret

# ------- Dynamic Types ------
.data

#===================== generateCode main =====================
.data
.main.S0:
  .string "Another Hello\n"
.main.S1:
  .string "abc"
.main.S2:
  .string "gString"
.main.S3:
  .string "Should not reach here:"
.main.S4:
  .string "key1"
.main.S5:
  .string "key2"
.main.S6:
  .string "map iteration %d times\n"
.main.S7:
  .string "key=%s, "
.main.S8:
  .string "value=%d\n"
.main.S9:
  .string "key=%s, "
.main.S10:
  .string "value=%d\n"
.main.S11:
  .string "Should not reach here:"
.main.S12:
  .string "key1"
.main.S13:
  .string "value1"
.main.S14:
  .string "key1"
.main.S15:
  .string "not found"
.main.S16:
  .string "key1=>\"%s\"\n"
.main.S17:
  .string "noexist"
.main.S18:
  .string "ERROR"
.main.S19:
  .string "noexist=>\"%s\"\n"
.main.S20:
  .string "key1"
.main.S21:
  .string "value1"
.main.S22:
  .string "key1"
.main.S23:
  .string "not found"
.main.S24:
  .string "key1=>\"%s\"\n"
.main.S25:
  .string "noexist"
.main.S26:
  .string "ERROR"
.main.S27:
  .string "noexist=>\"%s\"\n"
.main.S28:
  .string "len=>\"%d\"\n"
.main.S29:
  .string "key1"
.main.S30:
  .string "value1"
.main.S31:
  .string "len=>\"%d\"\n"
.main.S32:
  .string "noexist"
.main.S33:
  .string "noexist=>\"%s\"\n"
.main.S34:
  .string "key1"
.main.S35:
  .string "key1=>\"%s\"\n"
.main.S36:
  .string "key2"
.main.S37:
  .string "key2=>\"%s\"\n"
.main.S38:
  .string "key2"
.main.S39:
  .string "value2"
.main.S40:
  .string "key2"
.main.S41:
  .string "key2=>\"%s\"\n"
.main.S42:
  .string "len=>\"%d\"\n"
.main.S43:
  .string "key1"
.main.S44:
  .string "key1"
.main.S45:
  .string "key1=>\"%s\"\n"
.main.S46:
  .string "len=>\"%d\"\n"
.main.S47:
  .string "--------\n"
.main.S48:
  .string "len=>\"%d\"\n"
.main.S49:
  .string "i=>%d\n"
.main.S50:
  .string "i=>%d\n"
.main.S51:
  .string "mp.Len=%d\n"
.main.S52:
  .string "a"
.main.S53:
  .string "bb"
.main.S54:
  .string "mp.Len=%d\n"
.main.S55:
  .string "a"
.main.S56:
  .string "not found"
.main.S57:
  .string "mp.a=%d\n"
.main.S58:
  .string "bb"
.main.S59:
  .string "not found"
.main.S60:
  .string "mp.bb=%d\n"
.main.S61:
  .string "ccc"
.main.S62:
  .string "ccc"
.main.S63:
  .string "not found"
.main.S64:
  .string "mp.ccc=%d\n"
.main.S65:
  .string "bb"
.main.S66:
  .string "mp.Len=%d\n"
.main.S67:
  .string "bb"
.main.S68:
  .string "should not be present"
.main.S69:
  .string "mp.bb is nil\n"
.main.S70:
  .string "a"
.main.S71:
  .string "mp.Len=%d\n"
.main.S72:
  .string "ccc"
.main.S73:
  .string "mp.Len=%d\n"
.main.S74:
  .string "ERROR 0"
.main.S75:
  .string "ERROR 1"
.main.S76:
  .string "ERROR 2"
.main.S77:
  .string "I am nil\n"
.main.S78:
  .string "hello"
.main.S79:
  .string "hello"
.main.S80:
  .string "%s\n"
.main.S81:
  .string "i=%d\n"
.main.S82:
  .string "i=%d\n"
.main.S83:
  .string "mt.field=%d\n"
.main.S84:
  .string "hello"
.main.S85:
  .string "sqi=%s\n"
.main.S86:
  .string "mt.field=%d\n"
.main.S87:
  .string "456"
.main.S88:
  .string "aaa"
.main.S89:
  .string "bbb"
.main.S90:
  .string "ccc"
.main.S91:
  .string "abce=%d,%s,%s.%d\n"
.main.S92:
  .string "abc=%s,%s,%s\n"
.main.S93:
  .string "abc=%d,%d,%d\n"
.main.S94:
  .string "abc=%s\n"
.main.S95:
  .string "s=%s\n"
.main.S96:
  .string "hello"
.main.S97:
  .string "%%rax"
.main.S98:
  .string "number %d"
.main.S99:
  .string "I am string"
.main.S100:
  .string "string %s"
.main.S101:
  .string "types are %T"
.main.S102:
  .string "types are %T"
.main.S103:
  .string "types are %T"
.main.S104:
  .string "%d"
.main.S105:
  .string "xyz"
.main.S106:
  .string "c"
.main.S107:
  .string "efg"
.main.S108:
  .string "%dab%sd%s"
.main.S109:
  .string "string %d"
.main.S110:
  .string "%s"
.main.S111:
  .string "github.com/DQNEO/babygo/lib/strings"
.main.S112:
  .string "unsafe"
.main.S113:
  .string "reflect"
.main.S114:
  .string "github.com/DQNEO/babygo/lib/fmt"
.main.S115:
  .string "github.com/DQNEO/babygo/lib/mylib2"
.main.S116:
  .string "github.com/DQNEO/babygo/lib/strconv"
.main.S117:
  .string "syscall"
.main.S118:
  .string "github.com/DQNEO/babygo/lib/mylib"
.main.S119:
  .string "github.com/DQNEO/babygo/lib/path"
.main.S120:
  .string "os"
.main.S121:
  .string "github.com/DQNEO/babygo/lib/strings"
.main.S122:
  .string "unsafe"
.main.S123:
  .string "reflect"
.main.S124:
  .string "github.com/DQNEO/babygo/lib/fmt"
.main.S125:
  .string "github.com/DQNEO/babygo/lib/mylib2"
.main.S126:
  .string "github.com/DQNEO/babygo/lib/strconv"
.main.S127:
  .string "syscall"
.main.S128:
  .string "github.com/DQNEO/babygo/lib/mylib"
.main.S129:
  .string "github.com/DQNEO/babygo/lib/path"
.main.S130:
  .string "os"
.main.S131:
  .string "--------------------------------\n"
.main.S132:
  .string "%s\n"
.main.S133:
  .string "--------------------------------\n"
.main.S134:
  .string "%s\n"
.main.S135:
  .string "t"
.main.S136:
  .string "t"
.main.S137:
  .string "."
.main.S138:
  .string ".."
.main.S139:
  .string "%d\n"
.main.S140:
  .string "FOO"
.main.S141:
  .string "env FOO=%s\n"
.main.S142:
  .string "%s\n"
.main.S143:
  .string "%s\n"
.main.S144:
  .string "hello"
.main.S145:
  .string "%s\n"
.main.S146:
  .string "%s\n"
.main.S147:
  .string "%s\n"
.main.S148:
  .string "aa"
.main.S149:
  .string "bb"
.main.S150:
  .string "cc"
.main.S151:
  .string "aa"
.main.S152:
  .string "bb"
.main.S153:
  .string "cc"
.main.S154:
  .string "foo/bar"
.main.S155:
  .string "/"
.main.S156:
  .string "foo/bar"
.main.S157:
  .string "/"
.main.S158:
  .string "%d\n"
.main.S159:
  .string "%s\n"
.main.S160:
  .string "%s\n"
.main.S161:
  .string "foo bar buz"
.main.S162:
  .string "foo bar buz"
.main.S163:
  .string "foo"
.main.S164:
  .string "error"
.main.S165:
  .string " "
.main.S166:
  .string "error"
.main.S167:
  .string "buz"
.main.S168:
  .string "error"
.main.S169:
  .string "main.go"
.main.S170:
  .string "main.go"
.main.S171:
  .string ".go"
.main.S172:
  .string ".go"
.main.S173:
  .string "1\n"
.main.S174:
  .string "ERROR"
.main.S175:
  .string "foo/bar"
.main.S176:
  .string "/"
.main.S177:
  .string "ok\n"
.main.S178:
  .string "ERROR"
.main.S179:
  .string ""
.main.S180:
  .string ""
.main.S181:
  .string ""
.main.S182:
  .string ""
.main.S183:
  .string "12345"
.main.S184:
  .string "12345"
.main.S185:
  .string "/a/b"
.main.S186:
  .string "/"
.main.S187:
  .string ""
.main.S188:
  .string "/a/b/c"
.main.S189:
  .string "a/b/c"
.main.S190:
  .string "/a/"
.main.S191:
  .string "a/"
.main.S192:
  .string "/"
.main.S193:
  .string ""
.main.S194:
  .string "# testExtLib() => "
.main.S195:
  .string "foo"
.main.S196:
  .string "bar"
.main.S197:
  .string "buz"
.main.S198:
  .string "s1419"
.main.S199:
  .string "type is *int"
.main.S200:
  .string "type is string"
.main.S201:
  .string "ERROR"
.main.S202:
  .string "abcde"
.main.S203:
  .string "type is int"
.main.S204:
  .string "type is string"
.main.S205:
  .string "ERROR"
.main.S206:
  .string "type is MySruct"
.main.S207:
  .string "ERROR"
.main.S208:
  .string "ERROR"
.main.S209:
  .string "ERROR"
.main.S210:
  .string "type is bool"
.main.S211:
  .string "ifc is nil"
.main.S212:
  .string "ERROR"
.main.S213:
  .string "ERROR"
.main.S214:
  .string "type is bool"
.main.S215:
  .string "aaaa"
.main.S216:
  .string " type matched"
.main.S217:
  .string "FAILED"
.main.S218:
  .string "ok"
.main.S219:
  .string "FAILED"
.main.S220:
  .string "end of testInterfaceAssertion"
.main.S221:
  .string "FAILED"
.main.S222:
  .string "I am string"
.main.S223:
  .string "ok"
.main.S224:
  .string "FAILED"
.main.S225:
  .string "FAILED"
.main.S226:
  .string "1111"
.main.S227:
  .string "eface match"
.main.S228:
  .string "22222"
.main.S229:
  .string "3333"
.main.S230:
  .string "4444"
.main.S231:
  .string "eface not match"
.main.S232:
  .string "eface not match"
.main.S233:
  .string "eface is nil"
.main.S234:
  .string "geface is nil"
.main.S235:
  .string "geface is nil"
.main.S236:
  .string "eface is nil"
.main.S237:
  .string ""
.main.S238:
  .string ""
.main.S239:
  .string "gBool is true"
.main.S240:
  .string "infer string literal"
.main.S241:
  .string "infer string literal"
.main.S242:
  .string ""
.main.S243:
  .string "0"
.main.S244:
  .string "1"
.main.S245:
  .string "12"
.main.S246:
  .string "1234567890"
.main.S247:
  .string "-1234567890"
.main.S248:
  .string "-7"
.main.S249:
  .string "OK isLetter A"
.main.S250:
  .string "ERROR isLetter"
.main.S251:
  .string " nil vaargs ok"
.main.S252:
  .string "ERROR"
.main.S253:
  .string "pass nil slice\n"
.main.S254:
  .string "%s %s %s\n"
.main.S255:
  .string "a"
.main.S256:
  .string "bc"
.main.S257:
  .string "def"
.main.S258:
  .string "t/text.txt"
.main.S259:
  .string "ERROR"
.main.S260:
  .string "infer string literal"
.main.S261:
  .string "start"
.main.S262:
  .string "end"
.main.S263:
  .string "foo"
.main.S264:
  .string "fo"
.main.S265:
  .string "dummy"
.main.S266:
  .string "ERROR"
.main.S267:
  .string "x"
.main.S268:
  .string "o"
.main.S269:
  .string "swithc string 1 ok"
.main.S270:
  .string ""
.main.S271:
  .string "y"
.main.S272:
  .string "ERROR"
.main.S273:
  .string "ERROR"
.main.S274:
  .string ""
.main.S275:
  .string "ERROR"
.main.S276:
  .string "fo"
.main.S277:
  .string "ERROR"
.main.S278:
  .string "switch string default ok"
.main.S279:
  .string "fooo"
.main.S280:
  .string "ERROR"
.main.S281:
  .string "ERROR"
.main.S282:
  .string "switch uint8 ok"
.main.S283:
  .string "ERROR"
.main.S284:
  .string "ERROR"
.main.S285:
  .string "ERROR"
.main.S286:
  .string "switch default ok"
.main.S287:
  .string "ERROR"
.main.S288:
  .string "ERROR"
.main.S289:
  .string "switch int ok"
.main.S290:
  .string "ERROR"
.main.S291:
  .string "ERROR"
.main.S292:
  .string "ERROR"
.main.S293:
  .string "switch default ok"
.main.S294:
  .string "ERROR"
.main.S295:
  .string "true && true ok"
.main.S296:
  .string "ERROR"
.main.S297:
  .string "ERROR"
.main.S298:
  .string "true && false ok"
.main.S299:
  .string "ERROR"
.main.S300:
  .string "false && true ok"
.main.S301:
  .string "ERROR"
.main.S302:
  .string "false && false ok"
.main.S303:
  .string "true || true ok"
.main.S304:
  .string "ERROR"
.main.S305:
  .string "true || false ok"
.main.S306:
  .string "ERROR"
.main.S307:
  .string "false || true ok"
.main.S308:
  .string "ERROR"
.main.S309:
  .string "ERROR"
.main.S310:
  .string "false || false ok"
.main.S311:
  .string "\n"
.main.S312:
  .string "exit"
.main.S313:
  .string "exit"
.main.S314:
  .string "exit"
.main.S315:
  .string "exit"
.main.S316:
  .string "globalbool 1 ok"
.main.S317:
  .string "ERROR"
.main.S318:
  .string "ERROR"
.main.S319:
  .string "globalbool 2 ok"
.main.S320:
  .string "ERROR"
.main.S321:
  .string "globalbool 3 ok"
.main.S322:
  .string "bool 1 ok"
.main.S323:
  .string "ERROR"
.main.S324:
  .string "ERROR"
.main.S325:
  .string "bool ! 1 ok"
.main.S326:
  .string "bool 2 ok"
.main.S327:
  .string "ERROR"
.main.S328:
  .string "ERROR"
.main.S329:
  .string "bool 3 ok"
.main.S330:
  .string "nil pointer 1 ok"
.main.S331:
  .string "ERROR"
.main.S332:
  .string "nil pointer 2 ok"
.main.S333:
  .string "ERROR"
.main.S334:
  .string "nil pointer 3 ok"
.main.S335:
  .string "ERROR"
.main.S336:
  .string "nil pointer 4 ok"
.main.S337:
  .string "ERROR"
.main.S338:
  .string "this is "
.main.S339:
  .string "slice literal"
.main.S340:
  .string "\n"
.main.S341:
  .string "a"
.main.S342:
  .string "bb"
.main.S343:
  .string "ccc"
.main.S344:
  .string "\n"
.main.S345:
  .string "\n"
.main.S346:
  .string "aa"
.main.S347:
  .string "bb"
.main.S348:
  .string "|"
.main.S349:
  .string "\n"
.main.S350:
  .string "\n"
.main.S351:
  .string "a"
.main.S352:
  .string "bcde"
.main.S353:
  .string "fghijklmn\n"
.main.S354:
  .string "\n"
.main.S355:
  .string "abcde"
.main.S356:
  .string "abcdefghi"
.main.S357:
  .string "a"
.main.S358:
  .string "b"
.main.S359:
  .string "c"
.main.S360:
  .string "going to loop 0 times"
.main.S361:
  .string "ERROR"
.main.S362:
  .string ""
.main.S363:
  .string ""
.main.S364:
  .string "going to loop 2 times"
.main.S365:
  .string " in loop"
.main.S366:
  .string "going to loop 4 times"
.main.S367:
  .string ""
.main.S368:
  .string "hello"
.main.S369:
  .string "for"
.main.S370:
  .string "range"
.main.S371:
  .string ""
.main.S372:
  .string "-- testZeroValues()"
.main.S373:
  .string ""
.main.S374:
  .string "int zero ok"
.main.S375:
  .string "ERROR"
.main.S376:
  .string "aaa,"
.main.S377:
  .string "bbb,"
.main.S378:
  .string "ccc,"
.main.S379:
  .string "ddd,"
.main.S380:
  .string "hello"
.main.S381:
  .string " strings\n"
.main.S382:
  .string " globalstrings\n"
.main.S383:
  .string ""
.main.S384:
  .string "string cmp 1 ok"
.main.S385:
  .string "ERROR"
.main.S386:
  .string ""
.main.S387:
  .string "string cmp 2 ok"
.main.S388:
  .string "ERROR"
.main.S389:
  .string "abc"
.main.S390:
  .string "def"
.main.S391:
  .string "1abcdef1"
.main.S392:
  .string "string cmp 3 ok"
.main.S393:
  .string "ERROR"
.main.S394:
  .string "abcdef"
.main.S395:
  .string "string cmp 4 ok"
.main.S396:
  .string "ERROR"
.main.S397:
  .string "ERROR"
.main.S398:
  .string "string cmp not 1 ok"
.main.S399:
  .string "string cmp not 2 ok"
.main.S400:
  .string "ERROR"
.main.S401:
  .string "foo"
.main.S402:
  .string "bar"
.main.S403:
  .string "1234"
.main.S404:
  .string "hello\n"
.main.S405:
  .string "\n"
.main.S406:
  .string "\n"
.main.S407:
  .string "\n"
.main.S408:
  .string "A"
.main.S409:
  .string "\n"
.main.S410:
  .string "uint8 cmp == ok"
.main.S411:
  .string "ERROR"
.main.S412:
  .string "uint8 cmp != ok"
.main.S413:
  .string "uint8 cmp > ok"
.main.S414:
  .string "ERROR"
.main.S415:
  .string "uint8 cmp < ok"
.main.S416:
  .string "uint8 cmp >= ok"
.main.S417:
  .string "uint8 cmp <= ok"
.main.S418:
  .string "uint8 cmp == A ok"
.main.S419:
  .string "int cmp == ok"
.main.S420:
  .string "ERROR"
.main.S421:
  .string "int cmp != ok"
.main.S422:
  .string "int cmp > ok"
.main.S423:
  .string "ERROR"
.main.S424:
  .string "int cmp < ok"
.main.S425:
  .string "int cmp >= ok"
.main.S426:
  .string "int cmp <= ok"
.main.S427:
  .string "int cmp == A ok"
.main.S428:
  .string "ERROR"
.main.S429:
  .string "ok else if"
.main.S430:
  .string "ERROR"
.main.S431:
  .string "ERROR"
.main.S432:
  .string "ERROR"
.main.S433:
  .string "ok else if else"
.main.S434:
  .string "ok true"
.main.S435:
  .string "ERROR"
.main.S436:
  .string "ok false"
.main.S437:
  .string "ok true"
.main.S438:
  .string "ERROR"
.main.S439:
  .string "ERROR"
.main.S440:
  .string "ok false"
.main.S441:
  .string "globalstring changed\n"
.main.S442:
  .string "i am a local 1\n"
.main.S443:
  .string "hello string literal\n"
.main.S444:
  .string "hello string"
.main.S445:
  .string "i m local2\n"
.main.S446:
  .string "\n"
main.gmp: # T T_MAP
  .quad 0
main.anotherVar: # T T_STRING
  .quad .main.S0
  .quad 14
main.gArrayForFullSlice: # T T_ARRAY
  .quad 0 # int zero value
  .quad 0 # int zero value
  .quad 0 # int zero value
main.gefacearray: # T T_ARRAY
  .quad 0 # eface zero value (dtype)
  .quad 0 # eface zero value (data)
  .quad 0 # eface zero value (dtype)
  .quad 0 # eface zero value (data)
  .quad 0 # eface zero value (dtype)
  .quad 0 # eface zero value (data)
main.geface: # T T_INTERFACE
  .quad 0
  .quad 0
main.gi: # T T_INT
  .quad 123
main.gs: # T T_STRING
  .quad .main.S1
  .quad 3
main.gstrctPtr: # T T_POINTER
  .quad 0
main.gInt: # T T_INT
  .quad 1010
main.gBool: # T T_BOOL
  .quad 1 # bool true
main.gString: # T T_STRING
  .quad .main.S2
  .quad 7
main.gPointer: # T T_POINTER
  .quad 0
main.gChar: # T T_UINT8
  .byte 'A'
main.globalbool1: # T T_BOOL
  .quad 1 # bool true
main.globalbool2: # T T_BOOL
  .quad 0 # bool false
main.globalbool3: # T T_BOOL
  .quad 0 # bool zero value
main.nilSlice: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
main.globalstrings1: # T T_ARRAY
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
main.globalstrings2: # T T_ARRAY
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
main.__slice: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
main.globalstrings: # T T_ARRAY
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
  .quad 0 # string zero value (ptr)
  .quad 0 # string zero value (len)
main.structPointers: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
main.globalintarray: # T T_ARRAY
  .quad 0 # int zero value
  .quad 0 # int zero value
  .quad 0 # int zero value
  .quad 0 # int zero value
main.globalint: # T T_INT
  .quad 0
main.globalint2: # T T_INT
  .quad 0
main.globaluint8: # T T_UINT8
  .byte 0
main.globaluint16: # T T_UINT16
  .word 0
main.globalstring: # T T_STRING
  .quad 0
  .quad 0
main.globalarray: # T T_ARRAY
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
  .byte 0 # uint8 zero value
main.globalslice: # T T_SLICE
  .quad 0 # ptr
  .quad 0 # len
  .quad 0 # cap
main.globaluintptr: # T T_UINTPTR
  .quad 0

.text
main.__initGlobals:
  leaq main.gmp(%rip), %rax # global variable "gmp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $16 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeMap
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
# init global gstrctPtr:
  leaq main.gstrctPtr(%rip), %rax # global variable "gstrctPtr"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $456 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
# init global gPointer:
  leaq main.gPointer(%rip), %rax # global variable "gPointer"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $11 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $22 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  ret
# emitFuncDecl
main.testMapForrange: # args 16, locals -128
  pushq %rbp
  movq %rsp, %rbp
  subq $128, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $8 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeMap
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.158 # exit if nil
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.158:
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.158 # exit if nil
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 16(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 24(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .main.S3, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.gString(%rip), %rax # global variable "gString"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.gInt(%rip), %rax # global variable "gInt"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.post.158:
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.158
  .L.range.exit.158:
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S4, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $100 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S5, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $200 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.159 # exit if nil
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.159:
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.159 # exit if nil
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 16(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 24(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $23 # str len
  leaq .main.S6, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -56(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S7, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S8, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.159:
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.159
  .L.range.exit.159:
  leaq -80(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.160 # exit if nil
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.160:
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.160 # exit if nil
  leaq -104(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 16(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -112(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 24(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S9, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -104(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S10, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -112(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.160:
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.160
  .L.range.exit.160:
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  pushq $0 # T_MAP zero value
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -120(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "mapExpr"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -120(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.161 # exit if nil
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -120(%rbp), %rax # local variable ".range.map"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.161:
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  cmpq $0, %rax
  je .L.range.exit.161 # exit if nil
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 16(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  movq 24(%rax), %rcx
  pushq %rcx
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $22 # str len
  leaq .main.S11, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.gString(%rip), %rax # global variable "gString"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.gInt(%rip), %rax # global variable "gInt"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.post.161:
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  leaq -128(%rbp), %rax # local variable ".range.item"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.161
  .L.range.exit.161:
  leave
  ret
# emitFuncDecl
main.testGlobalMapOK: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  leaq main.gmp(%rip), %rax # global variable "gmp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S12, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $6 # str len
  leaq .main.S13, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S14, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.162 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_map_get.162
  .L.not_found.162:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_map_get.162:
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.163 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S15, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.163:
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S16, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $7 # str len
  leaq .main.S17, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.164 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_map_get.164
  .L.not_found.164:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_map_get.164:
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.165 # jmp if false
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S18, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.165:
  subq $40, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S19, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testMapOK: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $16 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeMap
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S20, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $6 # str len
  leaq .main.S21, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S22, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.166 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_map_get.166
  .L.not_found.166:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_map_get.166:
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.167 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S23, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.167:
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S24, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $7 # str len
  leaq .main.S25, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.168 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_map_get.168
  .L.not_found.168:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_map_get.168:
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.169 # jmp if false
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S26, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.169:
  subq $40, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S27, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testMap: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $16 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeMap
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S28, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.lenMap
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S29, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $6 # str len
  leaq .main.S30, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S31, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.lenMap
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "s0"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $7 # str len
  leaq .main.S32, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.170 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_map_get.170
  .L.not_found.170:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_map_get.170:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S33, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s0"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S34, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.171 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_map_get.171
  .L.not_found.171:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_map_get.171:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S35, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S36, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.172 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_map_get.172
  .L.not_found.172:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_map_get.172:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S37, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S38, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $6 # str len
  leaq .main.S39, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S40, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.173 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_map_get.173
  .L.not_found.173:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_map_get.173:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S41, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S42, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.lenMap
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S43, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.deleteMap
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # str len
  leaq .main.S44, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.174 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_map_get.174
  .L.not_found.174:
  popq %rax # result of T_POINTER
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_map_get.174:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S45, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S46, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.lenMap
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S47, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "mp2"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $8 # number literal
  popq %rax # result of T_UINTPTR
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeMap
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_MAP
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S48, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "mp2"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_MAP
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.lenMap
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "mp2"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.3(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.175 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_map_get.175
  .L.not_found.175:
  popq %rax # result of T_POINTER
  pushq $0 # T_INT zero value
  .L.end_map_get.175:
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S49, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -72(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "mp2"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.3(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapSet
  addq $24, %rsp # free parameters area
#  totalReturnSize=8
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "mp2"
  pushq %rax # variable address
  popq %rax # address of T_MAP
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_UINTPTR
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s0"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.3(%rip), %rax # dtype label address "unsafe.Pointer"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.getAddrForMapGet
  addq $24, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # result of map get:  ok value
  cmpq $1, %rax
  jne .L.not_found.176 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_map_get.176
  .L.not_found.176:
  popq %rax # result of T_POINTER
  pushq $0 # T_INT zero value
  .L.end_map_get.176:
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S50, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -72(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq os.Exit
  addq $8, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testMyMap: # args 16, locals -80
  pushq %rbp
  movq %rsp, %rbp
  subq $80, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S51, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mymap.$Map.Len
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # str len
  leaq .main.S52, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $11 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Set
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # str len
  leaq .main.S53, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $22 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Set
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S54, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mymap.$Map.Len
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # str len
  leaq .main.S55, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Get
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
# len lhs=2
# returnTypes=2
  leaq -24(%rbp), %rax # local variable "v1"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # eface.dtype
  popq %rcx # eface.data
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable "ok1"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "ok1"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.177 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S56, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.177:
  subq $40, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S57, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "v1"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.178.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.178.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.178.false # jump if nil
  jmp .L.cmpdtypes.178.cmp # jump to end
.L.cmpdtypes.178.true:
  pushq $1
  jmp .L.cmpdtypes.178.end # jump to end
.L.cmpdtypes.178.false:
  pushq $0
  jmp .L.cmpdtypes.178.end # jump to end
.L.cmpdtypes.178.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.178.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.179 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.179
  .L.unmatch.179:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  .L.end_type_assertion.179:
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # str len
  leaq .main.S58, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Get
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
# len lhs=2
# returnTypes=2
  leaq -48(%rbp), %rax # local variable "v2"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # eface.dtype
  popq %rcx # eface.data
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -56(%rbp), %rax # local variable "ok2"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "ok2"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.180 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S59, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.180:
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S60, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -48(%rbp), %rax # local variable "v2"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.181.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.181.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.181.false # jump if nil
  jmp .L.cmpdtypes.181.cmp # jump to end
.L.cmpdtypes.181.true:
  pushq $1
  jmp .L.cmpdtypes.181.end # jump to end
.L.cmpdtypes.181.false:
  pushq $0
  jmp .L.cmpdtypes.181.end # jump to end
.L.cmpdtypes.181.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.181.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.182 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.182
  .L.unmatch.182:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  .L.end_type_assertion.182:
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # str len
  leaq .main.S61, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $333 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Set
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # str len
  leaq .main.S62, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Get
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
# len lhs=2
# returnTypes=2
  leaq -72(%rbp), %rax # local variable "v3"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # eface.dtype
  popq %rcx # eface.data
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -80(%rbp), %rax # local variable "ok3"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "ok3"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.183 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S63, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.183:
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S64, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -72(%rbp), %rax # local variable "v3"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.184.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.184.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.184.false # jump if nil
  jmp .L.cmpdtypes.184.cmp # jump to end
.L.cmpdtypes.184.true:
  pushq $1
  jmp .L.cmpdtypes.184.end # jump to end
.L.cmpdtypes.184.false:
  pushq $0
  jmp .L.cmpdtypes.184.end # jump to end
.L.cmpdtypes.184.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.184.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.185 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.185
  .L.unmatch.185:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  .L.end_type_assertion.185:
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # str len
  leaq .main.S65, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Delete
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S66, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mymap.$Map.Len
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # str len
  leaq .main.S67, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Get
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
# len lhs=2
# returnTypes=2
  leaq -48(%rbp), %rax # local variable "v2"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # eface.dtype
  popq %rcx # eface.data
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -56(%rbp), %rax # local variable "ok2"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "ok2"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.186 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $21 # str len
  leaq .main.S68, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.186:
  subq $8, %rsp # alloc return vars area
  leaq -48(%rbp), %rax # local variable "v2"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  pushq $0 # interface data
  pushq $0 # interface dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.187 # jmp if false
  subq $40, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S69, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.187:
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # str len
  leaq .main.S70, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Delete
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S71, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mymap.$Map.Len
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # str len
  leaq .main.S72, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq mymap.$Map.Delete
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S73, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mymap.$Map.Len
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testTypeSwitchNil: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -16(%rbp), %rax # local variable "val"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable "val"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "val"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.190.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.190.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.190.false # jump if nil
  jmp .L.cmpdtypes.190.cmp # jump to end
.L.cmpdtypes.190.true:
  pushq $1
  jmp .L.cmpdtypes.190.end # jump to end
.L.cmpdtypes.190.false:
  pushq $0
  jmp .L.cmpdtypes.190.end # jump to end
.L.cmpdtypes.190.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.190.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.189 # jump if match
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.192.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.192.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.192.false # jump if nil
  jmp .L.cmpdtypes.192.cmp # jump to end
.L.cmpdtypes.192.true:
  pushq $1
  jmp .L.cmpdtypes.192.end # jump to end
.L.cmpdtypes.192.false:
  pushq $0
  jmp .L.cmpdtypes.192.end # jump to end
.L.cmpdtypes.192.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.192.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.191 # jump if match
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  pushq $0 # nil
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.195.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.195.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.195.false # jump if nil
  jmp .L.cmpdtypes.195.cmp # jump to end
.L.cmpdtypes.195.true:
  pushq $1
  jmp .L.cmpdtypes.195.end # jump to end
.L.cmpdtypes.195.false:
  pushq $0
  jmp .L.cmpdtypes.195.end # jump to end
.L.cmpdtypes.195.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.195.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.194 # jump if match
  jmp .L.case.193
.L.case.189:
  leaq -48(%rbp), %rax # local variable "vl"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S74, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "vl"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.188.exit
.L.case.191:
  leaq -56(%rbp), %rax # local variable "vl"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S75, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.188.exit
.L.case.193:
  subq $16, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S76, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.188.exit
.L.case.194:
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S77, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.188.exit
.L.typeswitch.188.exit:
  leave
  ret
# emitFuncDecl
main.testStructPointerMethodsByValue: # args 16, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.getField1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $20 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.setField1
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.getField1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testTokenString: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "tok"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S78, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S80, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "tok"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq token.Token.String
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAssignIncDec: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S81, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $3 # number literal
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S82, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testTypeAlias: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $216 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S83, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "mt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testDerivedString: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -16(%rbp), %rax # local variable "qi"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S84, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "sqi"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "qi"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S85, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "sqi"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testForeignType: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "mt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $216 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S86, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "mt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mylib.$Type.Method
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnMixed: # args 65, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S87, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 40(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  pushq $97 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq 41(%rbp), %rax # local variable ".r3"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq 57(%rbp), %rax # local variable ".r4"
  pushq %rax # variable address
  pushq $789 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.returnStrings: # args 64, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S88, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 32(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S89, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 48(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S90, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
main.returnInts: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1000 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  pushq $2000 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 32(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  pushq $3000 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.returnUint8s: # args 22, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 19(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq 20(%rbp), %rax # local variable ".r1"
  pushq %rax # variable address
  leaq 17(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq 21(%rbp), %rax # local variable ".r2"
  pushq %rax # variable address
  leaq 18(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testReturnMixed: # args 16, locals -49
  pushq %rbp
  movq %rsp, %rbp
  subq $49, %rsp # local area
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -41(%rbp), %rax # local variable "d"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -49(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $49, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnMixed
#  totalReturnSize=49
# len lhs=5
# returnTypes=5
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movzbq (%rsp), %rax # load uint8
  addq $1, %rsp # free returnvars area
  pushq %rax
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_UINT8
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -41(%rbp), %rax # local variable "d"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # eface.dtype
  popq %rcx # eface.data
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -49(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S91, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $64
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $1
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $48, %rax
  pushq %rax
  leaq -49(%rbp), %rax # local variable "e"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $4 # slice.cap
  pushq $4 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  leaq -41(%rbp), %rax # local variable "d"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leave
  ret
# emitFuncDecl
main.testReturnStrings: # args 16, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $48, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnStrings
#  totalReturnSize=48
# len lhs=3
# returnTypes=3
  leaq -16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S92, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  leaq -48(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testReturnInts: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $24, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnInts
#  totalReturnSize=24
# len lhs=3
# returnTypes=3
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S93, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testReturnUint8s: # args 16, locals -3
  pushq %rbp
  movq %rsp, %rbp
  subq $3, %rsp # local area
  leaq -1(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -2(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -3(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $3, %rsp # alloc return vars area
  subq $3, %rsp # alloc parameters area
  pushq $65 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $66 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 1(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $67 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 2(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq main.returnUint8s
  addq $3, %rsp # free parameters area
#  totalReturnSize=3
# len lhs=3
# returnTypes=3
  movzbq (%rsp), %rax # load uint8
  addq $1, %rsp # free returnvars area
  pushq %rax
  leaq -1(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_UINT8
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movzbq (%rsp), %rax # load uint8
  addq $1, %rsp # free returnvars area
  pushq %rax
  leaq -2(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_UINT8
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movzbq (%rsp), %rax # load uint8
  addq $1, %rsp # free returnvars area
  pushq %rax
  leaq -3(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_UINT8
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $40, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S94, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $3
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -1(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  leaq -2(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $2, %rax
  pushq %rax
  leaq -3(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.receiveBytes: # args 20, locals -1
  pushq %rbp
  movq %rsp, %rbp
  subq $1, %rsp # local area
  leaq -1(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  leaq 18(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq 19(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -1(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testPassBytes: # args 16, locals -43
  pushq %rbp
  movq %rsp, %rbp
  subq $43, %rsp # local area
  leaq -1(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $97 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -2(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $98 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -3(%rbp), %rax # local variable "rc"
  pushq %rax # variable address
  subq $1, %rsp # alloc return vars area
  subq $3, %rsp # alloc parameters area
  leaq -1(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -2(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 1(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $99 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 2(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq main.receiveBytes
  addq $3, %rsp # free parameters area
#  totalReturnSize=1
  movzbq (%rsp), %rax # load uint8
  addq $1, %rsp # free returnvars area
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -27(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $1
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -3(%rbp), %rax # local variable "rc"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -43(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -27(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S95, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -43(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSprinfMore: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S96, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S97, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $1234 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S98, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  pushq $11 # str len
  leaq .main.S99, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S100, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S101, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S102, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S103, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.4(%rip), %rax # dtype label address "*int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S104, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S105, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -64(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1234 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $1 # number literal
  leaq -64(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # str len
  leaq .main.S106, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $2 # number literal
  leaq -64(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $3 # str len
  leaq .main.S107, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S108, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -64(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S109, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S110, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $123 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAnotherFile: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.anotherFunc
#  totalReturnSize=16
  leave
  ret
# emitFuncDecl
main.testSortStrings: # args 16, locals -104
  pushq %rbp
  movq %rsp, %rbp
  subq $104, %rsp # local area
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $160
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $35 # str len
  leaq .main.S111, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $6 # str len
  leaq .main.S112, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $7 # str len
  leaq .main.S113, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $48, %rax
  pushq %rax
  pushq $31 # str len
  leaq .main.S114, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $64, %rax
  pushq %rax
  pushq $34 # str len
  leaq .main.S115, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $80, %rax
  pushq %rax
  pushq $35 # str len
  leaq .main.S116, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $96, %rax
  pushq %rax
  pushq $7 # str len
  leaq .main.S117, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $112, %rax
  pushq %rax
  pushq $33 # str len
  leaq .main.S118, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $128, %rax
  pushq %rax
  pushq $32 # str len
  leaq .main.S119, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $144, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S120, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # address of malloc
  pushq $10 # slice.cap
  pushq $10 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $40, %rsp # alloc parameters area
  pushq $33 # str len
  leaq .main.S131, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.196:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.196 # jmp if false
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S132, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.196:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.196
  .L.range.exit.196:
  subq $24, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq mylib.SortStrings
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $33 # str len
  leaq .main.S133, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.197:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.197 # jmp if false
  leaq -104(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "ss"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S134, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -104(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.197:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.197
  .L.range.exit.197:
  leave
  ret
# emitFuncDecl
main.testGetdents64: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -24(%rbp), %rax # local variable "dirents"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S135, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq mylib.GetDirents
  addq $16, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "dirents"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.198:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.198 # jmp if false
  leaq -72(%rbp), %rax # local variable "dirent"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "dirents"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "dirent"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .main.S137, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of left
  cmpq $1, %rax
  je .L.200.true
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "dirent"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $2 # str len
  leaq .main.S138, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  jmp .L.200.exit
  .L.200.true:
  pushq $1 # true
  .L.200.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.199 # jmp if false
jmp .L.range.post.198 # continue
  .L.endif.199:
  leaq -32(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.post.198:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.198
  .L.range.exit.198:
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S139, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "counter"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testEnv: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "gopath"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S140, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq os.Getenv
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $40, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S141, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -16(%rbp), %rax # local variable "gopath"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testReflect: # args 16, locals -56
  pushq %rbp
  movq %rsp, %rbp
  subq $56, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S142, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.4(%rip), %rax # dtype label address "*int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S143, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S144, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S145, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable "myStruct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "myStruct"
  pushq %rax # variable address
  popq %rax # address of T_STRUCT
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_STRUCT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.dtype.5(%rip), %rax # dtype label address "main.MyStruct"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S146, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -56(%rbp), %rax # local variable "myStructP"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "myStructP"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.6(%rip), %rax # dtype label address "*main.MyStruct"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq reflect.TypeOf
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S147, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "rt"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq reflect.$Type.String
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnSlice: # args 40, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S148, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S149, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S150, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testReturnSlice: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slice"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnSlice
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "slice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStrings: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S154, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .main.S155, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.Split
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S158, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S159, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S160, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "target"
  pushq %rax # variable address
  pushq $11 # str len
  leaq .main.S161, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "target"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $3 # str len
  leaq .main.S163, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.HasPrefix
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.201 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S164, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.201:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "target"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .main.S165, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.HasPrefix
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.202 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S166, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.202:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "target"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $3 # str len
  leaq .main.S167, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.HasPrefix
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.203 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S168, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.203:
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  pushq $7 # str len
  leaq .main.S169, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -72(%rbp), %rax # local variable "suffix"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S171, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -72(%rbp), %rax # local variable "suffix"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.HasSuffix
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.204 # jmp if false
  subq $40, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S173, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.204
  .L.else.204:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S174, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.204:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S175, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .main.S176, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strings.Contains
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.205 # jmp if false
  subq $40, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S177, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Printf
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.205
  .L.else.205:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S178, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.205:
  leave
  ret
# emitFuncDecl
main.testSliceExpr: # args 16, locals -224
  pushq %rbp
  movq %rsp, %rbp
  subq $224, %rsp # local area
  leaq -40(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $40
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $24, %rax
  pushq %rax
  pushq $4 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $5 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $40 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $4 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $1 # number literal
  leaq -40(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.206:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.206 # jmp if false
  leaq -96(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -96(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.206:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.206
  .L.range.exit.206:
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $2 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -40(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -104(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.207:
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -104(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.207 # jmp if false
  leaq -128(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -128(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.207:
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.207
  .L.range.exit.207:
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $5 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $1 # number literal
  leaq -40(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -136(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -144(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.208:
  leaq -144(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -136(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.208 # jmp if false
  leaq -160(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  leaq -144(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -160(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.208:
  leaq -144(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -144(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.208
  .L.range.exit.208:
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $5 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -40(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -168(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -176(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.209:
  leaq -176(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -168(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.209 # jmp if false
  leaq -192(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  leaq -176(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -192(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.209:
  leaq -176(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -176(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.209
  .L.range.exit.209:
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S183, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -224(%rbp), %rax # local variable "str2"
  pushq %rax # variable address
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $0 # number literal
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -224(%rbp), %rax # local variable "str2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $1 # number literal
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $0 # number literal
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $3 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $1 # number literal
  leaq -208(%rbp), %rax # local variable "str"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testPath: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S185, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Base
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S186, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Base
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Base
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S188, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S189, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S190, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S191, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S192, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq path.Dir
  addq $16, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testByteType: # args 16, locals -17
  pushq %rbp
  movq %rsp, %rbp
  subq $17, %rsp # local area
  leaq -1(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  pushq $120 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -17(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $1
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -1(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # address of malloc
  pushq $1 # slice.cap
  pushq $1 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -17(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testExtLib: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "y"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $4 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq mylib.Sum2
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $18 # str len
  leaq .main.S194, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "y"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.passVargs: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.takeInterfaceVaargs
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.takeStringVaargs: # args 40, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.210:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.210 # jmp if false
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.210:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.210
  .L.range.exit.210:
  leave
  ret
# emitFuncDecl
main.testExpandSlice: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slicexxx"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $2 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $4 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $6 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $0, %rsp # alloc parameters area
  callq main.nop
#  totalReturnSize=0
  subq $24, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slicexxx"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.passVargs
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $24, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S195, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S196, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S197, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.takeStringVaargs
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testFullSlice: # args 16, locals -88
  pushq %rbp
  movq %rsp, %rbp
  subq $88, %rsp # local area
  leaq main.gArrayForFullSlice(%rip), %rax # global variable "gArrayForFullSlice"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $4 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $6 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $24 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.211:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.211 # jmp if false
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.gArrayForFullSlice(%rip), %rax # global variable "gArrayForFullSlice"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.211:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.211
  .L.range.exit.211:
  leaq -56(%rbp), %rax # local variable "fullSlice"
  pushq %rax # variable address
  pushq $3 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # max
  subq %rcx, %rax # new cap = max - low
  pushq %rax # new cap
  pushq $2 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # new len = high - low
  pushq %rax # new len
  pushq $1 # number literal
  leaq main.gArrayForFullSlice(%rip), %rax # global variable "gArrayForFullSlice"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "fullSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "fullSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.212:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.212 # jmp if false
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable "fullSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.212:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.212
  .L.range.exit.212:
  leave
  ret
# emitFuncDecl
main.takeInterfaceVaargs: # args 40, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.213:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -8(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.213 # jmp if false
  leaq -40(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.213:
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.213
  .L.range.exit.213:
  leave
  ret
# emitFuncDecl
main.testInterfaceVaargs: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $1419 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S198, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $24, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -24(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $2 # slice.cap
  pushq $2 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.takeInterfaceVaargs
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnInterface: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $14 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testConvertToInterface: # args 16, locals -80
  pushq %rbp
  movq %rsp, %rbp
  subq $80, %rsp # local area
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  pushq $7 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.214.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.214.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.214.false # jump if nil
  jmp .L.cmpdtypes.214.cmp # jump to end
.L.cmpdtypes.214.true:
  pushq $1
  jmp .L.cmpdtypes.214.end # jump to end
.L.cmpdtypes.214.false:
  pushq $0
  jmp .L.cmpdtypes.214.end # jump to end
.L.cmpdtypes.214.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.214.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.215 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.215
  .L.unmatch.215:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.215:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $8 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.216.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.216.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.216.false # jump if nil
  jmp .L.cmpdtypes.216.cmp # jump to end
.L.cmpdtypes.216.true:
  pushq $1
  jmp .L.cmpdtypes.216.end # jump to end
.L.cmpdtypes.216.false:
  pushq $0
  jmp .L.cmpdtypes.216.end # jump to end
.L.cmpdtypes.216.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.216.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.217 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.217
  .L.unmatch.217:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.217:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  pushq $9 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -72(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.218.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.218.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.218.false # jump if nil
  jmp .L.cmpdtypes.218.cmp # jump to end
.L.cmpdtypes.218.true:
  pushq $1
  jmp .L.cmpdtypes.218.end # jump to end
.L.cmpdtypes.218.false:
  pushq $0
  jmp .L.cmpdtypes.218.end # jump to end
.L.cmpdtypes.218.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.218.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.219 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.219
  .L.unmatch.219:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.219:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -80(%rbp), %rax # local variable "l"
  pushq %rax # variable address
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  leaq main.gefacearray(%rip), %rax # global variable "gefacearray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -80(%rbp), %rax # local variable "l"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  pushq $2 # number literal
  leaq main.gefacearray(%rip), %rax # global variable "gefacearray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.220.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.220.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.220.false # jump if nil
  jmp .L.cmpdtypes.220.cmp # jump to end
.L.cmpdtypes.220.true:
  pushq $1
  jmp .L.cmpdtypes.220.end # jump to end
.L.cmpdtypes.220.false:
  pushq $0
  jmp .L.cmpdtypes.220.end # jump to end
.L.cmpdtypes.220.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.220.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.221 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.221
  .L.unmatch.221:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.221:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  pushq $11 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "k"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $16, %rax
  pushq %rax
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.222.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.222.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.222.false # jump if nil
  jmp .L.cmpdtypes.222.cmp # jump to end
.L.cmpdtypes.222.true:
  pushq $1
  jmp .L.cmpdtypes.222.end # jump to end
.L.cmpdtypes.222.false:
  pushq $0
  jmp .L.cmpdtypes.222.end # jump to end
.L.cmpdtypes.222.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.222.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.223 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.223
  .L.unmatch.223:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.223:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.gefacearray(%rip), %rax # global variable "gefacearray"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $0 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $0 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $12 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $48 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  pushq $2 # number literal
  leaq main.gefacearray(%rip), %rax # global variable "gefacearray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.224.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.224.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.224.false # jump if nil
  jmp .L.cmpdtypes.224.cmp # jump to end
.L.cmpdtypes.224.true:
  pushq $1
  jmp .L.cmpdtypes.224.end # jump to end
.L.cmpdtypes.224.false:
  pushq $0
  jmp .L.cmpdtypes.224.end # jump to end
.L.cmpdtypes.224.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.224.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.225 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.225
  .L.unmatch.225:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.225:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -80(%rbp), %rax # local variable "l"
  pushq %rax # variable address
  pushq $13 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -80(%rbp), %rax # local variable "l"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.takeInterface
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnInterface
#  totalReturnSize=16
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.226.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.226.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.226.false # jump if nil
  jmp .L.cmpdtypes.226.cmp # jump to end
.L.cmpdtypes.226.true:
  pushq $1
  jmp .L.cmpdtypes.226.end # jump to end
.L.cmpdtypes.226.false:
  pushq $0
  jmp .L.cmpdtypes.226.end # jump to end
.L.cmpdtypes.226.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.226.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.227 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.227
  .L.unmatch.227:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.227:
  popq %rax # result of T_BOOL
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testTypeSwitch: # args 16, locals -256
  pushq %rbp
  movq %rsp, %rbp
  subq $256, %rsp # local area
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $7 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.4(%rip), %rax # dtype label address "*int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -40(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -40(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.4(%rip), %rax # dtype label address "*int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.230.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.230.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.230.false # jump if nil
  jmp .L.cmpdtypes.230.cmp # jump to end
.L.cmpdtypes.230.true:
  pushq $1
  jmp .L.cmpdtypes.230.end # jump to end
.L.cmpdtypes.230.false:
  pushq $0
  jmp .L.cmpdtypes.230.end # jump to end
.L.cmpdtypes.230.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.230.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.229 # jump if match
  leaq -40(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.232.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.232.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.232.false # jump if nil
  jmp .L.cmpdtypes.232.cmp # jump to end
.L.cmpdtypes.232.true:
  pushq $1
  jmp .L.cmpdtypes.232.end # jump to end
.L.cmpdtypes.232.false:
  pushq $0
  jmp .L.cmpdtypes.232.end # jump to end
.L.cmpdtypes.232.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.232.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.231 # jump if match
  jmp .L.case.233
.L.case.229:
  leaq -48(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.4(%rip), %rax # dtype label address "*int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.234.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.234.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.234.false # jump if nil
  jmp .L.cmpdtypes.234.cmp # jump to end
.L.cmpdtypes.234.true:
  pushq $1
  jmp .L.cmpdtypes.234.end # jump to end
.L.cmpdtypes.234.false:
  pushq $0
  jmp .L.cmpdtypes.234.end # jump to end
.L.cmpdtypes.234.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.234.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.235 # jmp if false
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.235
  .L.unmatch.235:
  popq %rax # drop ifc.data
  pushq $0 # T_POINTER zero value
  .L.end_type_assertion.235:
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S199, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.228.exit
.L.case.231:
  leaq -64(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.236.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.236.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.236.false # jump if nil
  jmp .L.cmpdtypes.236.cmp # jump to end
.L.cmpdtypes.236.true:
  pushq $1
  jmp .L.cmpdtypes.236.end # jump to end
.L.cmpdtypes.236.false:
  pushq $0
  jmp .L.cmpdtypes.236.end # jump to end
.L.cmpdtypes.236.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.236.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.237 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  jmp .L.end_type_assertion.237
  .L.unmatch.237:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  .L.end_type_assertion.237:
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S200, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.228.exit
.L.case.233:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S201, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.228.exit
.L.typeswitch.228.exit:
  leaq -80(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S202, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.240.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.240.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.240.false # jump if nil
  jmp .L.cmpdtypes.240.cmp # jump to end
.L.cmpdtypes.240.true:
  pushq $1
  jmp .L.cmpdtypes.240.end # jump to end
.L.cmpdtypes.240.false:
  pushq $0
  jmp .L.cmpdtypes.240.end # jump to end
.L.cmpdtypes.240.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.240.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.239 # jump if match
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.242.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.242.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.242.false # jump if nil
  jmp .L.cmpdtypes.242.cmp # jump to end
.L.cmpdtypes.242.true:
  pushq $1
  jmp .L.cmpdtypes.242.end # jump to end
.L.cmpdtypes.242.false:
  pushq $0
  jmp .L.cmpdtypes.242.end # jump to end
.L.cmpdtypes.242.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.242.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.241 # jump if match
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  pushq $0 # nil
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.244.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.244.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.244.false # jump if nil
  jmp .L.cmpdtypes.244.cmp # jump to end
.L.cmpdtypes.244.true:
  pushq $1
  jmp .L.cmpdtypes.244.end # jump to end
.L.cmpdtypes.244.false:
  pushq $0
  jmp .L.cmpdtypes.244.end # jump to end
.L.cmpdtypes.244.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.244.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.243 # jump if match
  jmp .L.case.245
.L.case.239:
  leaq -104(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S203, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -104(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -112(%rbp), %rax # local variable "zzzzz"
  pushq %rax # variable address
  leaq -104(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -104(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -112(%rbp), %rax # local variable "zzzzz"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.238.exit
.L.case.241:
  leaq -128(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S204, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -128(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -128(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.238.exit
.L.case.243:
  subq $16, %rsp # alloc parameters area
  leaq -144(%rbp), %rax # local variable "xxx"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.238.exit
.L.case.245:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S205, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.238.exit
.L.typeswitch.238.exit:
  leaq -176(%rbp), %rax # local variable "srct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $111 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $222 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -176(%rbp), %rax # local variable "srct"
  pushq %rax # variable address
  popq %rax # address of T_STRUCT
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_STRUCT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.dtype.5(%rip), %rax # dtype label address "main.MyStruct"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -192(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -192(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.5(%rip), %rax # dtype label address "main.MyStruct"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.248.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.248.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.248.false # jump if nil
  jmp .L.cmpdtypes.248.cmp # jump to end
.L.cmpdtypes.248.true:
  pushq $1
  jmp .L.cmpdtypes.248.end # jump to end
.L.cmpdtypes.248.false:
  pushq $0
  jmp .L.cmpdtypes.248.end # jump to end
.L.cmpdtypes.248.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.248.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.247 # jump if match
  jmp .L.case.249
.L.case.247:
  leaq -224(%rbp), %rax # local variable "yyy"
  pushq %rax # variable address
  leaq -192(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRUCT
  pushq %rax
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S206, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -224(%rbp), %rax # local variable "yyy"
  pushq %rax # variable address
  leaq -192(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRUCT
  pushq %rax
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -224(%rbp), %rax # local variable "yyy"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.246.exit
.L.case.249:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S207, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.246.exit
.L.typeswitch.246.exit:
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  pushq $1 # true
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.7(%rip), %rax # dtype label address "bool"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -240(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -240(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.252.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.252.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.252.false # jump if nil
  jmp .L.cmpdtypes.252.cmp # jump to end
.L.cmpdtypes.252.true:
  pushq $1
  jmp .L.cmpdtypes.252.end # jump to end
.L.cmpdtypes.252.false:
  pushq $0
  jmp .L.cmpdtypes.252.end # jump to end
.L.cmpdtypes.252.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.252.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.251 # jump if match
  leaq -240(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.254.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.254.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.254.false # jump if nil
  jmp .L.cmpdtypes.254.cmp # jump to end
.L.cmpdtypes.254.true:
  pushq $1
  jmp .L.cmpdtypes.254.end # jump to end
.L.cmpdtypes.254.false:
  pushq $0
  jmp .L.cmpdtypes.254.end # jump to end
.L.cmpdtypes.254.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.254.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.253 # jump if match
  jmp .L.case.255
.L.case.251:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S208, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.250.exit
.L.case.253:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S209, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.250.exit
.L.case.255:
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S210, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.250.exit
.L.typeswitch.250.exit:
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -256(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -256(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  pushq $0 # nil
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.258.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.258.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.258.false # jump if nil
  jmp .L.cmpdtypes.258.cmp # jump to end
.L.cmpdtypes.258.true:
  pushq $1
  jmp .L.cmpdtypes.258.end # jump to end
.L.cmpdtypes.258.false:
  pushq $0
  jmp .L.cmpdtypes.258.end # jump to end
.L.cmpdtypes.258.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.258.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.257 # jump if match
  leaq -256(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.260.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.260.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.260.false # jump if nil
  jmp .L.cmpdtypes.260.cmp # jump to end
.L.cmpdtypes.260.true:
  pushq $1
  jmp .L.cmpdtypes.260.end # jump to end
.L.cmpdtypes.260.false:
  pushq $0
  jmp .L.cmpdtypes.260.end # jump to end
.L.cmpdtypes.260.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.260.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.259 # jump if match
  leaq -256(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.262.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.262.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.262.false # jump if nil
  jmp .L.cmpdtypes.262.cmp # jump to end
.L.cmpdtypes.262.true:
  pushq $1
  jmp .L.cmpdtypes.262.end # jump to end
.L.cmpdtypes.262.false:
  pushq $0
  jmp .L.cmpdtypes.262.end # jump to end
.L.cmpdtypes.262.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.262.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.261 # jump if match
  jmp .L.case.263
.L.case.257:
  subq $16, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S211, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.256.exit
.L.case.259:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S212, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.256.exit
.L.case.261:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S213, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.256.exit
.L.case.263:
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S214, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.typeswitch.256.exit
.L.typeswitch.256.exit:
  leave
  ret
# emitFuncDecl
main.makeInterface: # args 32, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  pushq $1829 # number literal
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "r"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testGetInterface: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.makeInterface
#  totalReturnSize=16
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.264.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.264.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.264.false # jump if nil
  jmp .L.cmpdtypes.264.cmp # jump to end
.L.cmpdtypes.264.true:
  pushq $1
  jmp .L.cmpdtypes.264.end # jump to end
.L.cmpdtypes.264.false:
  pushq $0
  jmp .L.cmpdtypes.264.end # jump to end
.L.cmpdtypes.264.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.264.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.265 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.265
  .L.unmatch.265:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.265:
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.266 # jmp if false
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.266:
  leave
  ret
# emitFuncDecl
main.takeInterface: # args 32, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.267.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.267.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.267.false # jump if nil
  jmp .L.cmpdtypes.267.cmp # jump to end
.L.cmpdtypes.267.true:
  pushq $1
  jmp .L.cmpdtypes.267.end # jump to end
.L.cmpdtypes.267.false:
  pushq $0
  jmp .L.cmpdtypes.267.end # jump to end
.L.cmpdtypes.267.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.267.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.268 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.268
  .L.unmatch.268:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.268:
  leaq -16(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.269 # jmp if false
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.269:
  leave
  ret
# emitFuncDecl
main.testPassInterface: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -8(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $1537 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.takeInterface
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testInterfaceAssertion: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable "ifc2"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $20210124 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S215, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.270.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.270.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.270.false # jump if nil
  jmp .L.cmpdtypes.270.cmp # jump to end
.L.cmpdtypes.270.true:
  pushq $1
  jmp .L.cmpdtypes.270.end # jump to end
.L.cmpdtypes.270.false:
  pushq $0
  jmp .L.cmpdtypes.270.end # jump to end
.L.cmpdtypes.270.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.270.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.271 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.271
  .L.unmatch.271:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.271:
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.272 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S216, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.272
  .L.else.272:
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S217, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.272:
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.273.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.273.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.273.false # jump if nil
  jmp .L.cmpdtypes.273.cmp # jump to end
.L.cmpdtypes.273.true:
  pushq $1
  jmp .L.cmpdtypes.273.end # jump to end
.L.cmpdtypes.273.false:
  pushq $0
  jmp .L.cmpdtypes.273.end # jump to end
.L.cmpdtypes.273.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.273.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.274 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.end_type_assertion.274
  .L.unmatch.274:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  .L.end_type_assertion.274:
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.275.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.275.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.275.false # jump if nil
  jmp .L.cmpdtypes.275.cmp # jump to end
.L.cmpdtypes.275.true:
  pushq $1
  jmp .L.cmpdtypes.275.end # jump to end
.L.cmpdtypes.275.false:
  pushq $0
  jmp .L.cmpdtypes.275.end # jump to end
.L.cmpdtypes.275.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.275.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.276 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.276
  .L.unmatch.276:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.276:
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_INT
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.277 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S218, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.277
  .L.else.277:
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S219, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.277:
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.278.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.278.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.278.false # jump if nil
  jmp .L.cmpdtypes.278.cmp # jump to end
.L.cmpdtypes.278.true:
  pushq $1
  jmp .L.cmpdtypes.278.end # jump to end
.L.cmpdtypes.278.false:
  pushq $0
  jmp .L.cmpdtypes.278.end # jump to end
.L.cmpdtypes.278.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.278.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.279 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.279
  .L.unmatch.279:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.279:
  popq %rax # result of T_BOOL
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.280.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.280.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.280.false # jump if nil
  jmp .L.cmpdtypes.280.cmp # jump to end
.L.cmpdtypes.280.true:
  pushq $1
  jmp .L.cmpdtypes.280.end # jump to end
.L.cmpdtypes.280.false:
  pushq $0
  jmp .L.cmpdtypes.280.end # jump to end
.L.cmpdtypes.280.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.280.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.281 # jmp if false
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # ok = true
  jmp .L.end_type_assertion.281
  .L.unmatch.281:
  popq %rax # drop ifc.data
  pushq $0 # T_INT zero value
  pushq $0 # ok = false
  .L.end_type_assertion.281:
  popq %rax # result of T_BOOL
  popq %rax # result of T_INT
  subq $16, %rsp # alloc parameters area
  pushq $29 # str len
  leaq .main.S220, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "ifc"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.282.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.282.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.282.false # jump if nil
  jmp .L.cmpdtypes.282.cmp # jump to end
.L.cmpdtypes.282.true:
  pushq $1
  jmp .L.cmpdtypes.282.end # jump to end
.L.cmpdtypes.282.false:
  pushq $0
  jmp .L.cmpdtypes.282.end # jump to end
.L.cmpdtypes.282.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.282.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.283 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_type_assertion.283
  .L.unmatch.283:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_type_assertion.283:
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.284 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S221, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.284
  .L.else.284:
  subq $16, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.284:
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $11 # str len
  leaq .main.S222, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "ifc2"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable "ifc2"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.285.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.285.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.285.false # jump if nil
  jmp .L.cmpdtypes.285.cmp # jump to end
.L.cmpdtypes.285.true:
  pushq $1
  jmp .L.cmpdtypes.285.end # jump to end
.L.cmpdtypes.285.false:
  pushq $0
  jmp .L.cmpdtypes.285.end # jump to end
.L.cmpdtypes.285.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.285.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.286 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_type_assertion.286
  .L.unmatch.286:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_type_assertion.286:
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.287 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S223, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.287
  .L.else.287:
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S224, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.287:
  leaq -32(%rbp), %rax # local variable "ifc2"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable "ifc2"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.288.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.288.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.288.false # jump if nil
  jmp .L.cmpdtypes.288.cmp # jump to end
.L.cmpdtypes.288.true:
  pushq $1
  jmp .L.cmpdtypes.288.end # jump to end
.L.cmpdtypes.288.false:
  pushq $0
  jmp .L.cmpdtypes.288.end # jump to end
.L.cmpdtypes.288.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.288.end:
  popq %rax # result of type assertion ok value
  cmpq $1, %rax
  jne .L.unmatch.289 # jmp if false
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  pushq $1 # ok = true
  jmp .L.end_type_assertion.289
  .L.unmatch.289:
  popq %rax # drop ifc.data
  pushq $0 # string len
  pushq $0 # string ptr
  pushq $0 # ok = false
  .L.end_type_assertion.289:
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_BOOL
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -40(%rbp), %rax # local variable "ok"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.290 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S225, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.290
  .L.else.290:
  subq $16, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.290:
  leave
  ret
# emitFuncDecl
main.testInterfaceimplicitConversion: # args 16, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $7 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S226, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc return vars area
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.291 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S227, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.291:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S228, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S229, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_POINTER
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.8(%rip), %rax # dtype label address "**[1][]*int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S230, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $8, %rsp # alloc return vars area
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.292 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S231, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.292:
  leaq -40(%rbp), %rax # local variable "m"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "m"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.9(%rip), %rax # dtype label address "main.MyType"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $8, %rsp # alloc return vars area
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.293 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S232, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.293:
  leave
  ret
# emitFuncDecl
main.testInterfaceZeroValue: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  pushq $0 # interface data
  pushq $0 # interface dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $8, %rsp # alloc return vars area
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  pushq $0 # interface data
  pushq $0 # interface dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.294 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S233, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.294:
  subq $8, %rsp # alloc return vars area
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  pushq $0 # interface data
  pushq $0 # interface dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.295 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S234, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.295:
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $8, %rsp # alloc return vars area
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  pushq $0 # interface data
  pushq $0 # interface dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.296 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S235, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.296:
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  leaq main.geface(%rip), %rax # global variable "geface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  subq $8, %rsp # alloc return vars area
  leaq -16(%rbp), %rax # local variable "eface"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  pushq $0 # interface data
  pushq $0 # interface dtype
  callq runtime.cmpinterface
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.297 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S236, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.297:
  leave
  ret
# emitFuncDecl
main.testForRangeShortDecl: # args 16, locals -96
  pushq %rbp
  movq %rsp, %rbp
  subq $96, %rsp # local area
  leaq -24(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $24, %rax
  pushq %rax
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # address of malloc
  pushq $4 # slice.cap
  pushq $4 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.298:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.298 # jmp if false
  leaq -56(%rbp), %rax # local variable "w"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "w"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.298:
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.298
  .L.range.exit.298:
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $20210122 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.299:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.299 # jmp if false
  leaq -96(%rbp), %rax # local variable "www"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -96(%rbp), %rax # local variable "www"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.299:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.299
  .L.range.exit.299:
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testInferVarTypes: # args 16, locals -56
  pushq %rbp
  movq %rsp, %rbp
  subq $56, %rsp # local area
  leaq -32(%rbp), %rax # local variable "gstrct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $789 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -56(%rbp), %rax # local variable "gslc"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq main.gi(%rip), %rax # global variable "gi"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq main.gs(%rip), %rax # global variable "gs"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $2 # number literal
  leaq -56(%rbp), %rax # local variable "gslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.gstrctPtr(%rip), %rax # global variable "gstrctPtr"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "gstrct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testGlobalValues: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  leaq main.gInt(%rip), %rax # global variable "gInt"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.gBool(%rip), %rax # global variable "gBool"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.300 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S239, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.300:
  subq $16, %rsp # alloc parameters area
  leaq main.gString(%rip), %rax # global variable "gString"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.gPointer(%rip), %rax # global variable "gPointer"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.gChar(%rip), %rax # global variable "gChar"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testShortVarDecl: # args 16, locals -56
  pushq %rbp
  movq %rsp, %rbp
  subq $56, %rsp # local area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.getField1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $20 # str len
  leaq .main.S240, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $3 # number literal
  pushq $5 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStructPointerMethods: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.getField1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "f1"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $20 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.setField1
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$MyStruct.getField1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.$MyStruct.getField1: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.$MyStruct.setField1: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq 24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
# emitFuncDecl
main.T.mv: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  leaq 24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
# emitFuncDecl
main.$T.mp: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 24(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
# emitFuncDecl
main.testPointerMethod: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.T.mv
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.$T.mp
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "v"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.MyAnotherType.add10: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testMethodAnother: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "y"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.MyAnotherType.add10
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "y"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.add10: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.MyType.add10: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testMethodSimple: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $4 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.MyType.add10
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.add10
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testOsArgs: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq os.Args(%rip), %rax # global variable "Args"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.301 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq os.Args(%rip), %rax # global variable "Args"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.301:
  leave
  ret
# emitFuncDecl
main.testStructLiteralWithContents: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $10 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $20 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $20 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "strctp"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $30 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (address of struct heaad) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $40 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "strctp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "strctp"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnPointerOfStruct: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $345 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $678 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testAddressOfStructLiteral: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnPointerOfStruct
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStructCopy: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $456 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_STRUCT
  pushq %rax
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $789 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStructLiteral: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $456 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStructZeroValue: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAtoi: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S243, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S244, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S245, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S246, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S247, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $2 # str len
  leaq .main.S248, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq strconv.Atoi
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.isLetter_: # args 25, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "ch"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $95 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.302 # jmp if false
  leaq 17(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  .L.endif.302:
  leaq 17(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $65 # convert char literal to int
  leaq 16(%rbp), %rax # local variable "ch"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.304.false
  leaq 16(%rbp), %rax # local variable "ch"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $90 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.304.exit
  .L.304.false:
  pushq $0 # false
  .L.304.exit:
  popq %rax # result of left
  cmpq $1, %rax
  je .L.303.true
  pushq $97 # convert char literal to int
  leaq 16(%rbp), %rax # local variable "ch"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.305.false
  leaq 16(%rbp), %rax # local variable "ch"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $122 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  jmp .L.305.exit
  .L.305.false:
  pushq $0 # false
  .L.305.exit:
  jmp .L.303.exit
  .L.303.true:
  pushq $1 # true
  .L.303.exit:
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testIsLetter: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # alloc return vars area
  subq $1, %rsp # alloc parameters area
  pushq $65 # convert char literal to int
  popq %rax # result of T_UINT8
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq main.isLetter_
  addq $1, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.306 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S249, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.306
  .L.else.306:
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S250, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.306:
  leave
  ret
# emitFuncDecl
main.funcVaarg1: # args 56, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq 32(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq fmt.Sprintf
  addq $40, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.funcVaarg2: # args 48, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.307 # jmp if false
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S251, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.307
  .L.else.307:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S252, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.307:
  leave
  ret
# emitFuncDecl
main.testVaargs: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S253, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.funcVaarg1
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $40, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S254, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # str len
  leaq .main.S255, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S256, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S257, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  popq %rax # address of malloc
  pushq $3 # slice.cap
  pushq $3 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.funcVaarg1
  addq $40, %rsp # free parameters area
#  totalReturnSize=0
  subq $32, %rsp # alloc parameters area
  pushq $777 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq main.funcVaarg2
  addq $32, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testOpenRead: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -8(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S258, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq syscall.Open
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
# len lhs=2
# returnTypes=2
  leaq -8(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_INT
  subq $16, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $300 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $300 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "fd"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq syscall.Read
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
# len lhs=2
# returnTypes=2
  leaq -40(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_INT
  leaq -40(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $279 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.308 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S259, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq runtime.panic
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.308:
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "readbytes"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  leaq -40(%rbp), %rax # local variable "n"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -32(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "readbytes"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testInfer: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $20 # str len
  leaq .main.S260, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $3 # number literal
  pushq $5 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # result of T_INT
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testEscapedChar: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "chars"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $5
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $92 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  pushq $9 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $2, %rax
  pushq %rax
  pushq $13 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $3, %rax
  pushq %rax
  pushq $39 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $4, %rax
  pushq %rax
  pushq $10 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # address of malloc
  pushq $5 # slice.cap
  pushq $5 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S261, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "chars"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S262, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSwitchString: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -16(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S263, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  pushq $2 # str len
  leaq .main.S264, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $5 # str len
  leaq .main.S265, %rax # str ptr
  pushq %rax # str ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.310 # jump if match
  jmp .L.switch.309.exit
  addq $16, %rsp # revert stack top
.L.case.310:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S266, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.309.exit
.L.switch.309.exit:
  leaq -16(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $1 # str len
  leaq .main.S267, %rax # str ptr
  pushq %rax # str ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.312 # jump if match
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # str len
  leaq .main.S268, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.312 # jump if match
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $0 # string len
  pushq $0 # string ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.313 # jump if match
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $1 # str len
  leaq .main.S271, %rax # str ptr
  pushq %rax # str ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.313 # jump if match
  jmp .L.case.314
  addq $16, %rsp # revert stack top
.L.case.312:
  subq $16, %rsp # alloc parameters area
  pushq $18 # str len
  leaq .main.S269, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.311.exit
.L.case.313:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S272, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.311.exit
.L.case.314:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S273, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.311.exit
.L.switch.311.exit:
  leaq -16(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $0 # string len
  pushq $0 # string ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.316 # jump if match
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $2 # str len
  leaq .main.S276, %rax # str ptr
  pushq %rax # str ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.317 # jump if match
  subq $8, %rsp # alloc return vars area
  movq 8+8(%rsp), %rcx # copy str.len from stack top (switch expr)
  movq 8+0(%rsp), %rax # copy str.ptr from stack top (switch expr)
  pushq %rcx # str.len
  pushq %rax # str.ptr
  pushq $4 # str len
  leaq .main.S279, %rax # str ptr
  pushq %rax # str ptr
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.319 # jump if match
  jmp .L.case.318
  addq $16, %rsp # revert stack top
.L.case.316:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S275, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.315.exit
.L.case.317:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S277, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.315.exit
.L.case.318:
  subq $16, %rsp # alloc parameters area
  pushq $24 # str len
  leaq .main.S278, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.315.exit
.L.case.319:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S280, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.315.exit
.L.switch.315.exit:
  leave
  ret
# emitFuncDecl
main.testSwitchByte: # args 16, locals -2
  pushq %rbp
  movq %rsp, %rbp
  subq $2, %rsp # local area
  leaq -1(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  pushq $99 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -2(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  pushq $97 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -1(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $98 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.321 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  leaq -2(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.322 # jump if match
  jmp .L.case.323
  addq $1, %rsp # revert stack top
.L.case.321:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S281, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.320.exit
.L.case.322:
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S282, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.320.exit
.L.case.323:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S283, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.320.exit
.L.switch.320.exit:
  leaq -1(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.325 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $98 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.326 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $100 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.328 # jump if match
  jmp .L.case.327
  addq $1, %rsp # revert stack top
.L.case.325:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S284, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.324.exit
.L.case.326:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S285, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.324.exit
.L.case.327:
  subq $16, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S286, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.324.exit
.L.case.328:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S287, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.324.exit
.L.switch.324.exit:
  leave
  ret
# emitFuncDecl
main.testSwitchInt: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  pushq $7 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  pushq $5 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.330 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  leaq -16(%rbp), %rax # local variable "caseVar"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.331 # jump if match
  jmp .L.case.332
  addq $8, %rsp # revert stack top
.L.case.330:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S288, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.329.exit
.L.case.331:
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S289, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.329.exit
.L.case.332:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S290, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.329.exit
.L.switch.329.exit:
  leaq -8(%rbp), %rax # local variable "testVar"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.334 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $6 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.335 # jump if match
  movq 0(%rsp), %rax # copy stack top value (switch expr) 
  pushq %rax
  pushq $8 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.337 # jump if match
  jmp .L.case.336
  addq $8, %rsp # revert stack top
.L.case.334:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S291, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.333.exit
.L.case.335:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S292, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.333.exit
.L.case.336:
  subq $16, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S293, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.333.exit
.L.case.337:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S294, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.switch.333.exit
.L.switch.333.exit:
  leave
  ret
# emitFuncDecl
main.testLogicalAndOr: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.339.false
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.339.exit
  .L.339.false:
  pushq $0 # false
  .L.339.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.338 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S295, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.338
  .L.else.338:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S296, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.338:
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.341.false
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.341.exit
  .L.341.false:
  pushq $0 # false
  .L.341.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.340 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S297, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.340
  .L.else.340:
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S298, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.340:
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.343.false
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.343.exit
  .L.343.false:
  pushq $0 # false
  .L.343.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.342 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S299, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.342
  .L.else.342:
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S300, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.342:
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  jne .L.345.false
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.345.exit
  .L.345.false:
  pushq $0 # false
  .L.345.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.344 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S301, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.344
  .L.else.344:
  subq $16, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S302, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.344:
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.347.true
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.347.exit
  .L.347.true:
  pushq $1 # true
  .L.347.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.346 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S303, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.346
  .L.else.346:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S304, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.346:
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.349.true
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.349.exit
  .L.349.true:
  pushq $1 # true
  .L.349.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.348 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S305, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.348
  .L.else.348:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S306, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.348:
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.351.true
  leaq -8(%rbp), %rax # local variable "t"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.351.exit
  .L.351.true:
  pushq $1 # true
  .L.351.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.350 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S307, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.350
  .L.else.350:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S308, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.350:
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of left
  cmpq $1, %rax
  je .L.353.true
  leaq -16(%rbp), %rax # local variable "f"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  jmp .L.353.exit
  .L.353.true:
  pushq $1 # true
  .L.353.exit:
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.352 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S309, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.352
  .L.else.352:
  subq $16, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S310, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.352:
  leave
  ret
# emitFuncDecl
main.testConst: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $24 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testForOmissible: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.354:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.355 # jmp if false
jmp .L.for.exit.354 # break
  .L.endif.355:
  .L.for.post.354:
  jmp .L.for.cond.354
  .L.for.exit.354:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.356:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $3 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.356 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.356:
  jmp .L.for.cond.356
  .L.for.exit.356:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.357:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $4 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.357 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.post.357:
  jmp .L.for.cond.357
  .L.for.exit.357:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S311, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testForBreakContinue: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.358:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.358 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $3 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.359 # jmp if false
jmp .L.for.exit.358 # break
  .L.endif.359:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.358:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.358
  .L.for.exit.358:
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S312, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.360:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.360 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $7 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.361 # jmp if false
jmp .L.for.post.360 # continue
  .L.endif.361:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.360:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.360
  .L.for.exit.360:
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S313, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $80
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $24, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $4 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $40, %rax
  pushq %rax
  pushq $5 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $48, %rax
  pushq %rax
  pushq $6 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $56, %rax
  pushq %rax
  pushq $7 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $64, %rax
  pushq %rax
  pushq $8 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $72, %rax
  pushq %rax
  pushq $9 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # address of malloc
  pushq $10 # slice.cap
  pushq $10 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.362:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.362 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $3 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.363 # jmp if false
jmp .L.range.exit.362 # break
  .L.endif.363:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.362:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.362
  .L.range.exit.362:
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S314, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.364:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.364 # jmp if false
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "ary"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $7 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.365 # jmp if false
jmp .L.range.post.364 # continue
  .L.endif.365:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.364:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.364
  .L.range.exit.364:
  subq $16, %rsp # alloc parameters area
  pushq $4 # str len
  leaq .main.S315, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnTrue1: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.returnTrue2: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  pushq $0 # T_BOOL zero value
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.returnFalse: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testGlobalBool: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq main.globalbool1(%rip), %rax # global variable "globalbool1"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.366 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S316, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.366
  .L.else.366:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S317, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.366:
  leaq main.globalbool2(%rip), %rax # global variable "globalbool2"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.367 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S318, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.367
  .L.else.367:
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S319, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.367:
  leaq main.globalbool3(%rip), %rax # global variable "globalbool3"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.368 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S320, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.368
  .L.else.368:
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S321, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.368:
  leave
  ret
# emitFuncDecl
main.testLocalBool: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnTrue1
#  totalReturnSize=8
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.369 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S322, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.369
  .L.else.369:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S323, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.369:
  leaq -8(%rbp), %rax # local variable "bol"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.370 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S324, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.370
  .L.else.370:
  subq $16, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S325, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.370:
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnTrue2
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.371 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S326, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.371
  .L.else.371:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S327, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.371:
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnFalse
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.372 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S328, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.372
  .L.else.372:
  subq $16, %rsp # alloc parameters area
  pushq $9 # str len
  leaq .main.S329, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.372:
  leave
  ret
# emitFuncDecl
main.testNilComparison: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.373 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S330, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.373
  .L.else.373:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S331, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.373:
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # T_POINTER zero value
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.374 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S332, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.374
  .L.else.374:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S333, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.374:
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.375 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S334, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.375
  .L.else.375:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S335, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.375:
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.376 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $16 # str len
  leaq .main.S336, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.376
  .L.else.376:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S337, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.376:
  leave
  ret
# emitFuncDecl
main.testSliceLiteral: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $8 # str len
  leaq .main.S338, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $13 # str len
  leaq .main.S339, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # address of malloc
  pushq $2 # slice.cap
  pushq $2 # slice.len
  pushq %rax # slice.ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testArrayCopy: # args 16, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $24 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable "bInt"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of T_ARRAY
  pushq %rax
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $24 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $20 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq -48(%rbp), %rax # local variable "bInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S340, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testLocalArrayWithMoreTypes: # args 16, locals -156
  pushq %rbp
  movq %rsp, %rbp
  subq $156, %rsp # local area
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $24 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.377:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.377 # jmp if false
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.377:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.377
  .L.range.exit.377:
  leaq -96(%rbp), %rax # local variable "aString"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $48
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # str len
  leaq .main.S341, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $2 # str len
  leaq .main.S342, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $32, %rax
  pushq %rax
  pushq $3 # str len
  leaq .main.S343, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $48 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -112(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -120(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -128(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.378:
  leaq -128(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -120(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.378 # jmp if false
  leaq -112(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -128(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -96(%rbp), %rax # local variable "aString"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -112(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.378:
  leaq -128(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -128(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.378
  .L.range.exit.378:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S344, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -132(%rbp), %rax # local variable "aByte"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $4
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $120 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  pushq $121 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $2, %rax
  pushq %rax
  pushq $122 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $3, %rax
  pushq %rax
  pushq $10 # number literal
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $4 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -156(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -132(%rbp), %rax # local variable "aByte"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -156(%rbp), %rax # local variable "buf"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testLocalArray: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $24
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  movq 0(%rsp), %rax # copy stack top value (malloced address) 
  pushq %rax
  popq %rax
  addq $16, %rax
  pushq %rax
  pushq $3 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  popq %rax # result of T_ARRAY
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $24 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "aInt"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S345, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAppendSlice: # args 16, locals -96
  pushq %rbp
  movq %rsp, %rbp
  subq $96, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $2 # str len
  leaq .main.S346, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $2 # str len
  leaq .main.S347, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $48, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.append24
  addq $48, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $48, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.append24
  addq $48, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $48, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq runtime.append24
  addq $48, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -88(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.379:
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -88(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.379 # jmp if false
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slcslc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $24, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.380:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -72(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.380 # jmp if false
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -48(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.380:
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -80(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.380
  .L.range.exit.380:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S348, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.379:
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.379
  .L.range.exit.379:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S349, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAppendPtr: # args 16, locals -56
  pushq %rbp
  movq %rsp, %rbp
  subq $56, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.381:
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.381 # jmp if false
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.append8
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.post.381:
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.381
  .L.for.exit.381:
  leaq -48(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.382:
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -48(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.382 # jmp if false
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.382:
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.382
  .L.range.exit.382:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S350, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAppendString: # args 16, locals -72
  pushq %rbp
  movq %rsp, %rbp
  subq $72, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $1 # str len
  leaq .main.S351, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $4 # str len
  leaq .main.S352, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  pushq $10 # str len
  leaq .main.S353, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $40, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "elm"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.append16
  addq $40, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -56(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.383:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.383 # jmp if false
  leaq -56(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.383:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.383
  .L.range.exit.383:
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAppendInt: # args 16, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.append8
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.384:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.384 # jmp if false
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.append8
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.post.384:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.384
  .L.for.exit.384:
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $10 # number literal
  popq %rax # result of T_INT
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.append8
  addq $32, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.385:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -40(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.385 # jmp if false
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.385:
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -48(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.385
  .L.range.exit.385:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S354, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testAppendByte: # args 16, locals -25
  pushq %rbp
  movq %rsp, %rbp
  subq $25, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  pushq $0 # T_UINT8 zero value
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  pushq $97 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  .L.for.cond.386:
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $122 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.386 # jmp if false
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  .L.for.post.386:
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  leaq -25(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  jmp .L.for.cond.386
  .L.for.exit.386:
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $25, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $10 # number literal
  popq %rax # result of T_UINT8
  leaq 24(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  callq runtime.append1
  addq $25, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSringIndex: # args 16, locals -17
  pushq %rbp
  movq %rsp, %rbp
  subq $17, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S355, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -17(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  pushq $3 # number literal
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -17(%rbp), %rax # local variable "char"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSubstring: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $9 # str len
  leaq .main.S356, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "subs"
  pushq %rax # variable address
  pushq $5 # number literal
  pushq $2 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $2 # number literal
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "subs"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSliceOfSlice: # args 16, locals -96
  pushq %rbp
  movq %rsp, %rbp
  subq $96, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $97 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $98 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $99 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable "slc1"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $3 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "slc1"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "slc2"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $2 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -72(%rbp), %rax # local variable "slc2"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -96(%rbp), %rax # local variable "slc3"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $3 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -96(%rbp), %rax # local variable "slc3"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testForrangeKey: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # str len
  leaq .main.S357, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # str len
  leaq .main.S358, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $2 # number literal
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # str len
  leaq .main.S359, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.387:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.387 # jmp if false
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -32(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.387:
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.387
  .L.range.exit.387:
  leave
  ret
# emitFuncDecl
main.testForrange: # args 16, locals -112
  pushq %rbp
  movq %rsp, %rbp
  subq $112, %rsp # local area
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  pushq $21 # str len
  leaq .main.S360, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.388:
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -48(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.388 # jmp if false
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S361, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.388:
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.388
  .L.range.exit.388:
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  pushq $21 # str len
  leaq .main.S364, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.389:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -64(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.389 # jmp if false
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S365, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.389:
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -72(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.389
  .L.range.exit.389:
  subq $16, %rsp # alloc parameters area
  pushq $21 # str len
  leaq .main.S366, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -80(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -88(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  pushq $4 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.390:
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -88(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.390 # jmp if false
  leaq -80(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -80(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.390:
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -96(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.390
  .L.range.exit.390:
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $5 # str len
  leaq .main.S368, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $3 # str len
  leaq .main.S369, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $5 # str len
  leaq .main.S370, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -104(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.range.cond.391:
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -104(%rbp), %rax # local variable ".range.len"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of  indexvar < lenvar
  cmpq $1, %rax
  jne .L.range.exit.391 # jmp if false
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.range.post.391:
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  leaq -112(%rbp), %rax # local variable ".range.index"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.range.cond.391
  .L.range.exit.391:
  subq $16, %rsp # alloc parameters area
  pushq $0 # string len
  pushq $0 # string ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.newStruct: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testNewStruct: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.newStruct
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testNilSlice: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $8 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq main.nilSlice(%rip), %rax # global variable "nilSlice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testZeroValues: # args 16, locals -56
  pushq %rbp
  movq %rsp, %rbp
  subq $56, %rsp # local area
  subq $16, %rsp # alloc parameters area
  pushq $19 # str len
  leaq .main.S372, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "h"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $2 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "h"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -56(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.392 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $11 # str len
  leaq .main.S374, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.392
  .L.else.392:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S375, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.392:
  leave
  ret
# emitFuncDecl
main.testIncrDecr: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testGlobalStrings: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  pushq $0 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $4 # str len
  leaq .main.S376, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $4 # str len
  leaq .main.S377, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # number literal
  leaq main.globalstrings2(%rip), %rax # global variable "globalstrings2"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $4 # str len
  leaq .main.S378, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq main.globalstrings2(%rip), %rax # global variable "globalstrings2"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $4 # str len
  leaq .main.S379, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.__slice(%rip), %rax # global variable "__slice"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $0 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # number literal
  leaq main.globalstrings1(%rip), %rax # global variable "globalstrings1"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testSliceOfStrings: # args 16, locals -64
  pushq %rbp
  movq %rsp, %rbp
  subq $64, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  pushq $5 # str len
  leaq .main.S380, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  pushq $9 # str len
  leaq .main.S381, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -56(%rbp), %rax # local variable "strings"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $16 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  leaq -56(%rbp), %rax # local variable "strings"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -16(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq -56(%rbp), %rax # local variable "strings"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.393:
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.393 # jmp if false
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -56(%rbp), %rax # local variable "strings"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.393:
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.393
  .L.for.exit.393:
  pushq $0 # number literal
  leaq main.globalstrings(%rip), %rax # global variable "globalstrings"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -16(%rbp), %rax # local variable "s1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $1 # number literal
  leaq main.globalstrings(%rip), %rax # global variable "globalstrings"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $15 # str len
  leaq .main.S382, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.394:
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.394 # jmp if false
  subq $16, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globalstrings(%rip), %rax # global variable "globalstrings"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $16, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.394:
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.394
  .L.for.exit.394:
  leave
  ret
# emitFuncDecl
main.testSliceOfPointers: # args 16, locals -96
  pushq %rbp
  movq %rsp, %rbp
  subq $96, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct1"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -72(%rbp), %rax # local variable "p1"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "strct1"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "p2"
  pushq %rax # variable address
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "strct1"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $11 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -64(%rbp), %rax # local variable "strct2"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $22 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.structPointers(%rip), %rax # global variable "structPointers"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $8 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq main.structPointers(%rip), %rax # global variable "structPointers"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -72(%rbp), %rax # local variable "p1"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  leaq main.structPointers(%rip), %rax # global variable "structPointers"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -80(%rbp), %rax # local variable "p2"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -96(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.395:
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $2 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.395 # jmp if false
  leaq -96(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.structPointers(%rip), %rax # global variable "structPointers"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -96(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.395:
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -88(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.395
  .L.for.exit.395:
  leave
  ret
# emitFuncDecl
main.testStructPointer: # args 16, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  leaq -32(%rbp), %rax # local variable "_strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "_strct"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $456 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "_strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $777 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStruct: # args 16, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $32
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_STRUCT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  pushq $32 # size
  pushq %rsi # dst lhs
  pushq %rax # src rhs
  callq runtime.memcopy
  addq $24, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  pushq $456 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  pushq $777 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $0, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "strct"
  pushq %rax # variable address
  popq %rax
  addq $8, %rax
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testPointer: # args 16, locals -57
  pushq %rbp
  movq %rsp, %rbp
  subq $57, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $12 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "j"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "p"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $11 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  pushq $65 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -33(%rbp), %rax # local variable "pc"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -33(%rbp), %rax # local variable "pc"
  pushq %rax # variable address
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -33(%rbp), %rax # local variable "pc"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $66 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -57(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -57(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -57(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  leaq -25(%rbp), %rax # local variable "c"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $16, %rsp # alloc parameters area
  leaq -57(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testDeclValue: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $123 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testStringComparison: # args 16, locals -80
  pushq %rbp
  movq %rsp, %rbp
  subq $80, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.396 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S384, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.396
  .L.else.396:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S385, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.396:
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "s2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.397 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S387, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.397
  .L.else.397:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S388, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.397:
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  pushq $3 # str len
  leaq .main.S389, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $3 # str len
  leaq .main.S390, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -64(%rbp), %rax # local variable "s4"
  pushq %rax # variable address
  pushq $8 # str len
  leaq .main.S391, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -80(%rbp), %rax # local variable "s5"
  pushq %rax # variable address
  pushq $7 # number literal
  pushq $1 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # len
  pushq $1 # number literal
  leaq -64(%rbp), %rax # local variable "s4"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rax # string.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -80(%rbp), %rax # local variable "s5"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.398 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S392, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.398
  .L.else.398:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S393, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.398:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $6 # str len
  leaq .main.S394, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -80(%rbp), %rax # local variable "s5"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.399 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S395, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.399
  .L.else.399:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S396, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.399:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -80(%rbp), %rax # local variable "s5"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.400 # jmp if false
  subq $16, %rsp # alloc parameters area
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq -80(%rbp), %rax # local variable "s5"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S397, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
  jmp .L.endif.400
  .L.else.400:
  subq $16, %rsp # alloc parameters area
  pushq $19 # str len
  leaq .main.S398, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.400:
  subq $8, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  leaq -64(%rbp), %rax # local variable "s4"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "s3"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.401 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $19 # str len
  leaq .main.S399, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.401
  .L.else.401:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S400, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.401:
  leave
  ret
# emitFuncDecl
main.testConcateStrings: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -16(%rbp), %rax # local variable "concatenated"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $3 # str len
  leaq .main.S401, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $3 # str len
  leaq .main.S402, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  pushq $4 # str len
  leaq .main.S403, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq runtime.catstrings
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "concatenated"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testLenCap: # args 16, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $0 # slice cap
  pushq $0 # slice len
  pushq $0 # slice ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $12 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $24 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rdx # cap
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $4 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $4 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $6 # str len
  leaq .main.S404, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # len
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testMakeSlice: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  subq $24, %rsp # alloc return vars area
  subq $24, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $20 # number literal
  popq %rax # result of T_INT
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq runtime.makeSlice
  addq $24, %rsp # free parameters area
#  totalReturnSize=24
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $65 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $66 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $67 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testNew: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_POINTER zero value
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  pushq $8
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_POINTER
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_POINTER
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testItoa: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $12 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $123 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $12345 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $12345678 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1234567890 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $54321 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $54321 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $7654321 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  pushq $1234567890 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testIndexExprOfArray: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  pushq $0 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $11 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $22 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $44 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S405, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testIndexExprOfSlice: # args 16, locals -32
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp # local area
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  pushq $0 # number literal
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $66 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $77 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $2 # number literal
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $1 # number literal
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  pushq $3 # number literal
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $88 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.402:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $4 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.402 # jmp if false
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -24(%rbp), %rax # local variable "intslice"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rax # slice.ptr
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.402:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.402
  .L.for.exit.402:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S406, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.403:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $4 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.403 # jmp if false
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globalintarray(%rip), %rax # global variable "globalintarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $8, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.403:
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.403
  .L.for.exit.403:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S407, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testFor: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  .L.for.cond.404:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $3 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of for condition
  cmpq $1, %rax
  jne .L.for.exit.404 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S408, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.for.post.404:
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "i"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  jmp .L.for.cond.404
  .L.for.exit.404:
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S409, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testCmpUint8: # args 16, locals -1
  pushq %rbp
  movq %rsp, %rbp
  subq $1, %rsp # local area
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.405 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S410, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.405:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.406 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S411, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.406
  .L.else.406:
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S412, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.406:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.407 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S413, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.407:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.408 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S414, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.408
  .L.else.408:
  subq $16, %rsp # alloc parameters area
  pushq $14 # str len
  leaq .main.S415, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.408:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.409 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S416, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.409:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.410 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S417, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.410:
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  pushq $101 # number literal
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -1(%rbp), %rax # local variable "localuint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  pushq $65 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.411 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $17 # str len
  leaq .main.S418, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.411:
  leave
  ret
# emitFuncDecl
main.testCmpInt: # args 16, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.412 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S419, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.412:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of 
  xor $1, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.413 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S420, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.413
  .L.else.413:
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S421, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.413:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setg %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.414 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S422, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.414:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $0 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.415 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S423, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.415
  .L.else.415:
  subq $16, %rsp # alloc parameters area
  pushq $12 # str len
  leaq .main.S424, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.415:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setge %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.416 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S425, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.416:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  setle %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.417 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $13 # str len
  leaq .main.S426, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.417:
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  pushq $101 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $65 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  cmpq %rcx, %rax
  sete %al
  movzbq %al, %rax
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.418 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S427, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.418:
  leave
  ret
# emitFuncDecl
main.testElseIf: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  pushq $0 # false
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.419 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S428, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.419
  .L.else.419:
  pushq $1 # true
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.420 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $10 # str len
  leaq .main.S429, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.420
  .L.else.420:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S430, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.420:
  .L.endif.419:
  pushq $0 # false
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.421 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S431, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.421
  .L.else.421:
  pushq $0 # false
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.422 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S432, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.422
  .L.else.422:
  subq $16, %rsp # alloc parameters area
  pushq $15 # str len
  leaq .main.S433, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.422:
  .L.endif.421:
  leave
  ret
# emitFuncDecl
main.testIf: # args 16, locals -16
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # local area
  leaq -8(%rbp), %rax # local variable "tr"
  pushq %rax # variable address
  pushq $1 # true
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "fls"
  pushq %rax # variable address
  pushq $0 # false
  popq %rax # result of T_BOOL
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "tr"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.423 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S434, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.423:
  leaq -16(%rbp), %rax # local variable "fls"
  pushq %rax # variable address
  popq %rax # address of T_BOOL
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.endif.424 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S435, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.424:
  subq $16, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S436, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testElse: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  pushq $1 # true
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.425 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $7 # str len
  leaq .main.S437, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.425
  .L.else.425:
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S438, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.425:
  pushq $0 # false
  popq %rax # result of if condition
  cmpq $1, %rax
  jne .L.else.426 # jmp if false
  subq $16, %rsp # alloc parameters area
  pushq $5 # str len
  leaq .main.S439, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  jmp .L.endif.426
  .L.else.426:
  subq $16, %rsp # alloc parameters area
  pushq $8 # str len
  leaq .main.S440, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  .L.endif.426:
  leave
  ret
# emitFuncDecl
main.assignGlobal: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq main.globalint(%rip), %rax # global variable "globalint"
  pushq %rax # variable address
  pushq $22 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.globaluint8(%rip), %rax # global variable "globaluint8"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq main.globaluint16(%rip), %rax # global variable "globaluint16"
  pushq %rax # variable address
  pushq $5 # number literal
  popq %rax # result of T_UINT16
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movw %ax, 0(%rsi) # assign word
  leaq main.globaluintptr(%rip), %rax # global variable "globaluintptr"
  pushq %rax # variable address
  pushq $7 # number literal
  popq %rax # result of T_UINTPTR
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.globalstring(%rip), %rax # global variable "globalstring"
  pushq %rax # variable address
  pushq $21 # str len
  leaq .main.S441, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
# emitFuncDecl
main.add1: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $1 # number literal
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.sum: # args 40, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 32(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq 24(%rbp), %rax # local variable "y"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.print1: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
  leave
  ret
# emitFuncDecl
main.print2: # args 48, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "a"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq 32(%rbp), %rax # local variable "b"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.returnstring: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  pushq $15 # str len
  leaq .main.S442, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testGlobalCharArray: # args 16, locals -24
  pushq %rbp
  movq %rsp, %rbp
  subq $24, %rsp # local area
  pushq $0 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $65 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $1 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $66 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $2 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $0 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $3 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $100 # number literal
  pushq $10 # number literal
  popq %rcx # right
  popq %rax # left
  movq $0, %rdx # init %rdx
  divq %rcx
  pushq %rax
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  pushq $1 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  pushq $66 # convert char literal to int
  popq %rax # result of T_UINT8
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movb %al, 0(%rsi) # assign byte
  leaq -24(%rbp), %rax # local variable "chars"
  pushq %rax # variable address
  pushq $9 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  leaq -24(%rbp), %rax # local variable "chars"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq main.globalslice(%rip), %rax # global variable "globalslice"
  pushq %rax # variable address
  leaq -24(%rbp), %rax # local variable "chars"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc parameters area
  pushq $9 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # orig_cap
  subq %rcx, %rax # orig_cap - low
  pushq %rax # new cap
  pushq $4 # number literal
  pushq $0 # number literal
  popq %rcx # low
  popq %rax # high
  subq %rcx, %rax # high - low
  pushq %rax # new len
  pushq $0 # number literal
  leaq main.globalarray(%rip), %rax # global variable "globalarray"
  pushq %rax # variable address
  popq %rax # address of list head
  popq %rcx # index id
  movq $1, %rdx # elm size
  imulq %rdx, %rcx
  addq %rcx, %rax
  pushq %rax # addr of element
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  pushq %rcx # str len
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testString: # args 16, locals -48
  pushq %rbp
  movq %rsp, %rbp
  subq $48, %rsp # local area
  subq $16, %rsp # alloc parameters area
  leaq main.globalstring(%rip), %rax # global variable "globalstring"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.assignGlobal
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $21 # str len
  leaq .main.S443, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq main.print1
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $12 # str len
  leaq .main.S444, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leaq -32(%rbp), %rax # local variable "localstring1"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.returnstring
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "localstring2"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "localstring2"
  pushq %rax # variable address
  pushq $11 # str len
  leaq .main.S445, %rax # str ptr
  pushq %rax # str ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  subq $16, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "localstring1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq main.print1
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $32, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "localstring1"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -48(%rbp), %rax # local variable "localstring2"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  leaq 16(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  callq main.print2
  addq $32, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  leaq main.globalstring(%rip), %rax # global variable "globalstring"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.testArgAssign: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $13 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 24(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testMinus: # args 24, locals -8
  pushq %rbp
  movq %rsp, %rbp
  subq $8, %rsp # local area
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  pushq $1 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  pushq $5 # number literal
  popq %rax # e.X
  imulq $-1, %rax
  pushq %rax
  popq %rcx # right
  popq %rax # left
  imulq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq -8(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leave
  ret
  leave
  ret
# emitFuncDecl
main.testMisc: # args 16, locals -40
  pushq %rbp
  movq %rsp, %rbp
  subq $40, %rsp # local area
  leaq -8(%rbp), %rax # local variable "i13"
  pushq %rax # variable address
  pushq $0 # number literal
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i13"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -8(%rbp), %rax # local variable "i13"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.testArgAssign
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "i5"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $0, %rsp # alloc parameters area
  callq main.testMinus
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.globalint2(%rip), %rax # global variable "globalint2"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -8(%rbp), %rax # local variable "i13"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq -16(%rbp), %rax # local variable "i5"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  movq $0, %rdx # init %rdx
  divq %rcx
  movq %rdx, %rax
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.sum
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "locali3"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  pushq $51 # convert char literal to int
  pushq $49 # convert char literal to int
  popq %rcx # right
  popq %rax # left
  subq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globaluint16(%rip), %rax # global variable "globaluint16"
  pushq %rax # variable address
  popq %rax # address of T_UINT16
  movzwq 0(%rax), %rax # load uint16
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globaluint8(%rip), %rax # global variable "globaluint8"
  pushq %rax # variable address
  popq %rax # address of T_UINT8
  movzbq 0(%rax), %rax # load uint8
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  leaq main.globaluintptr(%rip), %rax # global variable "globaluintptr"
  pushq %rax # variable address
  popq %rax # address of T_UINTPTR
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -24(%rbp), %rax # local variable "locali3"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -32(%rbp), %rax # local variable "tmp"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.add1
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i42"
  pushq %rax # variable address
  pushq $0 # T_INT zero value
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -40(%rbp), %rax # local variable "i42"
  pushq %rax # variable address
  subq $8, %rsp # alloc return vars area
  subq $16, %rsp # alloc parameters area
  leaq main.globalint(%rip), %rax # global variable "globalint"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq main.globalint2(%rip), %rax # global variable "globalint2"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq main.sum
  addq $16, %rsp # free parameters area
#  totalReturnSize=8
  leaq -24(%rbp), %rax # local variable "locali3"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rcx # right
  popq %rax # left
  addq %rcx, %rax
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  subq $16, %rsp # alloc parameters area
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "i42"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.writeln
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.main: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $0, %rsp # alloc parameters area
  callq main.testMapForrange
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGlobalMapOK
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMapOK
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMap
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMyMap
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testTypeSwitchNil
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructPointerMethodsByValue
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testTokenString
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAssignIncDec
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testTypeAlias
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testDerivedString
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForeignType
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReturnMixed
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReturnStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReturnInts
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReturnUint8s
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testPassBytes
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSprinfMore
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAnotherFile
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSortStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGetdents64
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testEnv
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReflect
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testReturnSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSliceExpr
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testPath
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testByteType
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testExtLib
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testExpandSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testFullSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInterfaceVaargs
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testConvertToInterface
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testTypeSwitch
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGetInterface
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testPassInterface
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInterfaceAssertion
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInterfaceimplicitConversion
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInterfaceZeroValue
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForRangeShortDecl
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInferVarTypes
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGlobalValues
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testShortVarDecl
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructPointerMethods
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testPointerMethod
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMethodAnother
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMethodSimple
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testOsArgs
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructLiteralWithContents
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAddressOfStructLiteral
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructCopy
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructLiteral
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructZeroValue
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAtoi
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testIsLetter
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testVaargs
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testOpenRead
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testInfer
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testEscapedChar
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSwitchString
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSwitchByte
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSwitchInt
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testLogicalAndOr
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testConst
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForOmissible
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForBreakContinue
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGlobalBool
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testLocalBool
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testNilComparison
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSliceLiteral
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testArrayCopy
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testLocalArrayWithMoreTypes
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testLocalArray
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAppendSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAppendPtr
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAppendString
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAppendInt
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testAppendByte
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSringIndex
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSubstring
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSliceOfSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForrangeKey
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testForrange
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testNewStruct
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testNilSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testZeroValues
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testIncrDecr
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGlobalStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSliceOfStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testSliceOfPointers
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStructPointer
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStruct
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testPointer
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testDeclValue
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testStringComparison
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testConcateStrings
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testLenCap
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMakeSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testNew
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testItoa
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testIndexExprOfArray
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testIndexExprOfSlice
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testString
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testFor
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testCmpUint8
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testCmpInt
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testElseIf
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testElse
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testIf
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testGlobalCharArray
#  totalReturnSize=0
  subq $0, %rsp # alloc parameters area
  callq main.testMisc
#  totalReturnSize=0
  subq $8, %rsp # alloc parameters area
  pushq $0 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq os.Exit
  addq $8, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret
# emitFuncDecl
main.anotherFunc: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leaq 16(%rbp), %rax # local variable ".r0"
  pushq %rax # variable address
  leaq main.anotherVar(%rip), %rax # global variable "anotherVar"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leave
  ret
  leave
  ret
# emitFuncDecl
main.nop: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leave
  ret
# emitFuncDecl
main.nop1: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leave
  ret
# emitFuncDecl
main.nop2: # args 16, locals 0
  pushq %rbp
  movq %rsp, %rbp
  leave
  ret
# emitFuncDecl
main.write: # args 32, locals -80
  pushq %rbp
  movq %rsp, %rbp
  subq $80, %rsp # local area
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  pushq $0 # string len
  pushq $0 # string ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  leaq 16(%rbp), %rax # local variable "x"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.2(%rip), %rax # dtype label address "int"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.429.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.429.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.429.false # jump if nil
  jmp .L.cmpdtypes.429.cmp # jump to end
.L.cmpdtypes.429.true:
  pushq $1
  jmp .L.cmpdtypes.429.end # jump to end
.L.cmpdtypes.429.false:
  pushq $0
  jmp .L.cmpdtypes.429.end # jump to end
.L.cmpdtypes.429.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.429.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.428 # jump if match
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of type switch subject
  movq (%rax), %rax # dtype label addr
  pushq %rax # dtype label addr
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rdx           # dtype label address A
  popq %rcx           # dtype label address B
  cmpq %rcx, %rdx
  je .L.cmpdtypes.431.true # jump if match
  cmpq $0, %rdx # check if A is nil
  je .L.cmpdtypes.431.false # jump if nil
  cmpq $0, %rcx # check if B is nil
  je .L.cmpdtypes.431.false # jump if nil
  jmp .L.cmpdtypes.431.cmp # jump to end
.L.cmpdtypes.431.true:
  pushq $1
  jmp .L.cmpdtypes.431.end # jump to end
.L.cmpdtypes.431.false:
  pushq $0
  jmp .L.cmpdtypes.431.end # jump to end
.L.cmpdtypes.431.cmp:
  subq $8, %rsp # alloc return vars area
  movq 16(%rax), %rdx           # str.len of dtype A
  pushq %rdx
  movq 8(%rax), %rdx           # str.ptr of dtype A
  pushq %rdx
  movq 16(%rcx), %rdx           # str.len of dtype B
  pushq %rdx
  movq 8(%rcx), %rdx           # str.ptr of dtype B
  pushq %rdx
  callq runtime.cmpstrings
  addq $32, %rsp # free parameters area
.L.cmpdtypes.431.end:
  popq %rax # result of  of switch-case comparison
  cmpq $1, %rax
  je .L.case.430 # jump if match
  jmp .L.typeswitch.427.exit
.L.case.428:
  leaq -40(%rbp), %rax # local variable "xx"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  subq $16, %rsp # alloc return vars area
  subq $8, %rsp # alloc parameters area
  leaq -40(%rbp), %rax # local variable "xx"
  pushq %rax # variable address
  popq %rax # address of T_INT
  movq 0(%rax), %rax # load 64
  pushq %rax
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  callq strconv.Itoa
  addq $8, %rsp # free parameters area
#  totalReturnSize=16
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.427.exit
.L.case.430:
  leaq -56(%rbp), %rax # local variable "xx"
  pushq %rax # variable address
  leaq -32(%rbp), %rax # local variable ".switch_expr"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # ifc.dtype
  popq %rcx # ifc.data
  pushq %rcx # ifc.data
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  leaq -56(%rbp), %rax # local variable "xx"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  jmp .L.typeswitch.427.exit
.L.typeswitch.427.exit:
  leaq -80(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  leaq -16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_STRING
  movq 8(%rax), %rdx # len
  movq 0(%rax), %rax # ptr
  pushq %rdx # len
  pushq %rax # ptr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rcx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  popq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  subq $16, %rsp # alloc return vars area
  subq $32, %rsp # alloc parameters area
  pushq $1 # number literal
  popq %rax # result of T_INT
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # assign
  leaq -80(%rbp), %rax # local variable "slc"
  pushq %rax # variable address
  popq %rax # address of T_SLICE
  movq 16(%rax), %rdx
  movq 8(%rax), %rcx
  movq 0(%rax), %rax
  pushq %rdx # cap
  pushq %rcx # len
  pushq %rax # ptr
  popq %rax # slice.ptr
  popq %rcx # slice.len
  popq %rdx # slice.cap
  leaq 8(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  movq %rdx, 16(%rsi) # cap to cap
  callq syscall.Write
  addq $32, %rsp # free parameters area
#  totalReturnSize=16
  leave
  ret
# emitFuncDecl
main.writeln: # args 32, locals 0
  pushq %rbp
  movq %rsp, %rbp
  subq $16, %rsp # alloc parameters area
  leaq 16(%rbp), %rax # local variable "s"
  pushq %rax # variable address
  popq %rax # address of T_INTERFACE
  movq 8(%rax), %rdx # data
  movq 0(%rax), %rax # dtype
  pushq %rdx # data
  pushq %rax # dtype
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  subq $16, %rsp # alloc parameters area
  pushq $1 # str len
  leaq .main.S446, %rax # str ptr
  pushq %rax # str ptr
  subq $8, %rsp # alloc return vars area
  pushq $16
  callq runtime.malloc
  addq $8, %rsp # free parameters area
#  totalReturnSize=8
  popq %rsi # lhs addr
  popq %rax # string.ptr
  popq %rcx # string.len
  pushq %rsi # lhs addr
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # ptr to ptr
  movq %rcx, 8(%rsi) # len to len
  leaq main.dtype.1(%rip), %rax # dtype label address "string"
  pushq %rax           # dtype label address
  popq %rax # eface.dtype
  popq %rcx # eface.data
  leaq 0(%rsp), %rsi # place to save
  pushq %rsi # place to save
  popq %rsi # place to save
  movq %rax, 0(%rsi) # store dtype
  movq %rcx, 8(%rsi) # store data
  callq main.write
  addq $16, %rsp # free parameters area
#  totalReturnSize=0
  leave
  ret

# ------- Dynamic Types ------
.data
main.dtype.1: # main:string
  .quad 1
  .quad .main.S.dtype.1
  .quad 6
.main.S.dtype.1:
  .string "string"
main.dtype.2: # main:int
  .quad 2
  .quad .main.S.dtype.2
  .quad 3
.main.S.dtype.2:
  .string "int"
main.dtype.3: # main:unsafe.Pointer
  .quad 3
  .quad .main.S.dtype.3
  .quad 14
.main.S.dtype.3:
  .string "unsafe.Pointer"
main.dtype.4: # main:*int
  .quad 4
  .quad .main.S.dtype.4
  .quad 4
.main.S.dtype.4:
  .string "*int"
main.dtype.5: # main:main.MyStruct
  .quad 5
  .quad .main.S.dtype.5
  .quad 13
.main.S.dtype.5:
  .string "main.MyStruct"
main.dtype.6: # main:*main.MyStruct
  .quad 6
  .quad .main.S.dtype.6
  .quad 14
.main.S.dtype.6:
  .string "*main.MyStruct"
main.dtype.7: # main:bool
  .quad 7
  .quad .main.S.dtype.7
  .quad 4
.main.S.dtype.7:
  .string "bool"
main.dtype.8: # main:**[1][]*int
  .quad 8
  .quad .main.S.dtype.8
  .quad 11
.main.S.dtype.8:
  .string "**[1][]*int"
main.dtype.9: # main:main.MyType
  .quad 9
  .quad .main.S.dtype.9
  .quad 11
.main.S.dtype.9:
  .string "main.MyType"

